<feed xmlns="http://www.w3.org/2005/Atom"><title type="text">nullfactory.net</title><subtitle type="text">nullfactory.net</subtitle><id>http://nullfactory.net/</id><updated>2017-05-01T02:04:36+10:00</updated><author><name>Shane Carvalho</name><uri>http://nullfactory.net</uri><email>shanec_@hotmail.com</email></author><generator>Sandra.Snow Atom Generator</generator><link rel="alternate" href="http://nullfactory.net/feed.xml" /><link rel="self" type="text/html" title="nullfactory.net" href="http://nullfactory.net/feed.xml" /><entry><id>http://nullfactory.net/2017/04/enforce-commit-message-standards-and-generate-changelogs-via-git/</id><title type="text">Enforce Commit Message Standards and Generate Changelogs via Git</title><summary type="html">&lt;p&gt;In past projects my release note strategy has been a combination of custom scripts (to pull the changesets between releases) and good old fashioned elbow grease to manually create the notes. I was curious to know ways about the ways to achieve the same in git and learning about the techniques used in popular open source projects.  &lt;/p&gt;

&lt;p&gt;In order to automatically generate a changelog the repository requires consistent commits - and I found that there are three steps that can be done to achieve this: &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Enforcing commit message rules.&lt;/li&gt;
&lt;li&gt;Install and setup tools that help generate commit messages that are compliant.&lt;/li&gt;
&lt;li&gt;Generate the changelog for the project based on the commits.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Prerequisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Node.js - instructions on installing node can be found &lt;a href="https://docs.npmjs.com/getting-started/installing-node"&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;package.json&lt;/code&gt; file for your project. One can be generated by navigating to the root folder of the project, run the &lt;code&gt;npm init&lt;/code&gt; command and follow the instructions&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Enforcing Commit Message Rules&lt;/h2&gt;

&lt;p&gt;The enforcing of the rules are done using &lt;code&gt;husky&lt;/code&gt; and &lt;code&gt;validate-commit-msg&lt;/code&gt; packages. &lt;code&gt;Husky&lt;/code&gt; makes it very easy to tap into the commit event and execute custom validation scripts and uses &lt;a href="https://tygertec.com/git-hooks-practical-uses-windows/"&gt;git hooks&lt;/a&gt; to do this. &lt;code&gt;validate-commit-msg&lt;/code&gt; implements the validation scheme - conventional commits - that we would be used when the commit occurs.&lt;/p&gt;

&lt;p&gt;The &lt;a href="https://conventionalcommits.org/"&gt;conventional commits specification site&lt;/a&gt; summarizes its advantages very well:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
  &lt;li&gt;Automatically generating CHANGELOGs.&lt;/li&gt;
  &lt;li&gt;Automatically determining a semantic version bump (based on the types of commits landed).&lt;/li&gt;
  &lt;li&gt;Communicating the nature of changes to teammates, the public, and other stakeholders.&lt;/li&gt;
  &lt;li&gt;Triggering build and publish processes.&lt;/li&gt;
  &lt;li&gt;Making it easier for people to contribute to your projects, by allowing them to explore a more structured commit history.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

</summary><published>2017-04-29T14:00:00Z</published><updated>2017-04-29T14:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/04/enforce-commit-message-standards-and-generate-changelogs-via-git/" /><content type="html">&lt;p&gt;In past projects my release note strategy has been a combination of custom scripts (to pull the changesets between releases) and good old fashioned elbow grease to manually create the notes. I was curious to know ways about the ways to achieve the same in git and learning about the techniques used in popular open source projects.  &lt;/p&gt;

&lt;p&gt;In order to automatically generate a changelog the repository requires consistent commits - and I found that there are three steps that can be done to achieve this: &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Enforcing commit message rules.&lt;/li&gt;
&lt;li&gt;Install and setup tools that help generate commit messages that are compliant.&lt;/li&gt;
&lt;li&gt;Generate the changelog for the project based on the commits.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Prerequisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Node.js - instructions on installing node can be found &lt;a href="https://docs.npmjs.com/getting-started/installing-node"&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;package.json&lt;/code&gt; file for your project. One can be generated by navigating to the root folder of the project, run the &lt;code&gt;npm init&lt;/code&gt; command and follow the instructions&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Enforcing Commit Message Rules&lt;/h2&gt;

&lt;p&gt;The enforcing of the rules are done using &lt;code&gt;husky&lt;/code&gt; and &lt;code&gt;validate-commit-msg&lt;/code&gt; packages. &lt;code&gt;Husky&lt;/code&gt; makes it very easy to tap into the commit event and execute custom validation scripts and uses &lt;a href="https://tygertec.com/git-hooks-practical-uses-windows/"&gt;git hooks&lt;/a&gt; to do this. &lt;code&gt;validate-commit-msg&lt;/code&gt; implements the validation scheme - conventional commits - that we would be used when the commit occurs.&lt;/p&gt;

&lt;p&gt;The &lt;a href="https://conventionalcommits.org/"&gt;conventional commits specification site&lt;/a&gt; summarizes its advantages very well:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
  &lt;li&gt;Automatically generating CHANGELOGs.&lt;/li&gt;
  &lt;li&gt;Automatically determining a semantic version bump (based on the types of commits landed).&lt;/li&gt;
  &lt;li&gt;Communicating the nature of changes to teammates, the public, and other stakeholders.&lt;/li&gt;
  &lt;li&gt;Triggering build and publish processes.&lt;/li&gt;
  &lt;li&gt;Making it easier for people to contribute to your projects, by allowing them to explore a more structured commit history.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;!--excerpt--&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;First, navigate to the root of your project folder and install &lt;code&gt;husky&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install husky --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, install the &lt;code&gt;validate-commit-msg&lt;/code&gt; package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install --save-dev validate-commit-msg
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Update the &lt;code&gt;package.json&lt;/code&gt; scripts node to let husky know that we want to use the &lt;code&gt;validate-commit-msg&lt;/code&gt; validations with &lt;code&gt;husky&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;"scripts": {
    "commitmsg": "validate-commit-msg"
},
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;From now on any commits done would be validated against the standard. &lt;/p&gt;

&lt;h2&gt;Scaffold and Commit&lt;/h2&gt;

&lt;p&gt;Now that we have the validation in place, let make life easier by installing some tools that help us adhere to the rules. &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Install &lt;code&gt;Commitizen&lt;/code&gt; by running the following command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g commitizen 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Install the &lt;code&gt;cz-conventional-changelog&lt;/code&gt; adapter as part of the project - this is the conventional commits guide lines. Read more about this standard &lt;a href="https://conventionalcommits.org/"&gt;here&lt;/a&gt; and &lt;a href="https://github.com/angular/angular.js/blob/master/CONTRIBUTING.md#-git-commit-guidelines"&gt;here&lt;/a&gt;. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;commitizen init cz-conventional-changelog --save-dev --save-exact
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Verify that commitizen has been conifgured automatically in the &lt;code&gt;package.json&lt;/code&gt;: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  "config": {
    "commitizen": {
      "path": "./node_modules/cz-conventional-changelog"
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now that we have commitizen and its adapter installed, now its time to do some commits. The following command now replaces the usual &lt;code&gt;git commit&lt;/code&gt; command: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git cz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It would guide you interactively to create the best commit message based on the &lt;code&gt;conventional-changelog&lt;/code&gt; adapter. Find a recap of the message format &lt;a href="http://karma-runner.github.io/0.10/dev/git-commit-msg.html"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/ConventionalCommit/10_commitizen.png" alt="Commitizen" /&gt;&lt;/p&gt;

&lt;h2&gt;Generate Changelog&lt;/h2&gt;

&lt;p&gt;Now to generate the changelog. In my non-node.js based projects, I usually rely on the build process to bump the version number of the release, but node.js projects and tools appear to like the explicit versioning in the &lt;code&gt;package.json&lt;/code&gt; file and the same checked into source control. I can work with that.&lt;/p&gt;

&lt;p&gt;The following is the &lt;a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli#recommended-workflow"&gt;recommended workflow&lt;/a&gt; for generating the changelog:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
  &lt;li&gt;Make changes&lt;/li&gt;
  &lt;li&gt;Commit those changes&lt;/li&gt;
  &lt;li&gt;Make sure Travis turns green&lt;/li&gt;
  &lt;li&gt;Bump version in package.json&lt;/li&gt;
  &lt;li&gt;conventionalChangelog&lt;/li&gt;
  &lt;li&gt;Commit package.json and CHANGELOG.md files&lt;/li&gt;
  &lt;li&gt;Tag&lt;/li&gt;
  &lt;li&gt;Push&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let's adapt these steps to work with our own workflow:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;I am going to install the command line version of &lt;code&gt;conventional-changelog&lt;/code&gt; which is &lt;code&gt;conventional-changelog-cli&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g conventional-changelog-cli
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Since this is the first time I am running it, I want the changelog to take all historical commits into consideration. I am going to run the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;conventional-changelog -p angular -i CHANGELOG.md -s -r 0
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-p&lt;/code&gt; being the preset being used. I am using &lt;code&gt;angular&lt;/code&gt; in this case and uses this kind . More detailed explanation of the format can be found &lt;a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#"&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-i&lt;/code&gt; the input file.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt; indicates that the input file and the output file are the same.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r 0&lt;/code&gt; How many releases to be generated from the latest. If &lt;code&gt;0&lt;/code&gt;, the whole changelog will be regenerated and the outfile will be overwritten Default: &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The full list of options available can be found by executing &lt;code&gt;conventional-changelog --help&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Continue creating commits using the &lt;code&gt;git cz&lt;/code&gt; command. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;If you have a CI build setup, make sure that its successful. Then update the version number in the &lt;code&gt;package.json&lt;/code&gt; to a higher one.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now lets update the changelog using the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;conventional-changelog -p angular -i CHANGELOG.md -s 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Confirm that the changelog has been updated with the new significant features. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Commit the changes back into git.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;These same steps can be applied to almost any project type including .NET. So I am pretty excited to test this out in the Dynamics CRM/365 projects. I also found out that visual studio 2017 &lt;a href="https://andrewlock.net/git-integration-improvements-in-visual-studio-2017/"&gt;plays nice with git hooks&lt;/a&gt;.  &lt;/p&gt;

&lt;h3&gt;Client Side&lt;/h3&gt;

&lt;p&gt;It is important to remember that Git Hooks are client site and that it can be &lt;a href="https://tygertec.com/git-hooks-practical-uses-windows/"&gt;overridden&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;... Client side hooks can often be bypassed, either by using low-level “plumbing” commands instead of the high-level “porcelain” commands, and often by passing the &lt;code&gt;–no-verify&lt;/code&gt; option to the command. For example, &lt;code&gt;git commit –no-verify&lt;/code&gt; will not run the pre-commit hook. ...&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;On an open-source project, maybe the maintainer could possibly eye-ball the pull request and ensure that it is valid or squash and provide a different message?&lt;/p&gt;

&lt;h3&gt;Versioning&lt;/h3&gt;

&lt;p&gt;Since the &lt;code&gt;package.json&lt;/code&gt; would be driving the version number, in my .NET/Dynamics CRM projects, I can possibly implement a PowerShell script that would bumps the version of the CRM solution based on the &lt;code&gt;package.json&lt;/code&gt; instead of the build.&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.npmjs.com/getting-started/installing-node"&gt;02 - Installing Node.js and updating npm | npm Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli"&gt;conventional-changelog/packages/conventional-changelog-cli at master · conventional-changelog/conventional-changelog · GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.npmjs.com/cli/init"&gt;init | npm Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://notebook.aaronwest.net/2015/08/03/better-documentation-using-conventional-changelog.html"&gt;Better Documentation Using Conventional-Changelog - aaron’s engineering notebook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://conventionalcommits.org/"&gt;Conventional Commits 1.0.0-beta - Conventional Commits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://karma-runner.github.io/0.10/dev/git-commit-msg.html"&gt;Karma - Git Commit Msg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#"&gt;Git Commit Message Conventions - Google Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://commitizen.github.io/cz-cli/"&gt;Commitizen by commitizen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commitizen/cz-cli"&gt;GitHub - commitizen/cz-cli: The commitizen command line utility.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/kentcdodds/validate-commit-msg"&gt;GitHub - kentcdodds/validate-commit-msg: githook to validate commit messages are up to standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/typicode/husky"&gt;GitHub - typicode/husky: Git hooks made easy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/41785974/how-can-i-use-husky-to-check-a-git-commit-message-format/41787949#41787949"&gt;How can I use husky to check a git commit message format? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://andrewlock.net/git-integration-improvements-in-visual-studio-2017/"&gt;Git integration improvements in Visual Studio 2017 - git-hooks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tygertec.com/git-hooks-practical-uses-windows/"&gt;Git hooks, practical uses (yes, even on Windows) » tygertec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.atlassian.com/git/tutorials/git-hooks"&gt;Git Hooks | Atlassian Git Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-release-part-3/</id><title type="text">Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 3 - Release and Deployment</title><summary type="html">&lt;p&gt;In this third and final installment I cover the steps involved in setting up the minimum release and deployment steps required for a successful Dynamics CRM/365 deployment. The steps and actions performed in the previous posts acts as prerequisites for this one.&lt;/p&gt;

&lt;p&gt;Related posts from the series:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-setup-part-1/"&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 1 - Setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-build-part-2/"&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 2 - Build&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 3 - Release and Deployment&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;The Packages&lt;/h2&gt;

&lt;p&gt;In the &lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-build-part-2/"&gt;previous post&lt;/a&gt;, I setup the team build to automatically publish packages into the Octopus Deploy package repository. &lt;/p&gt;

&lt;p&gt;We can verify that they have indeed been published by navigating to the &lt;code&gt;Library &amp;gt; Packages&lt;/code&gt; tab for a list of available packages.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/05_published_package.png" alt="Available Packages" /&gt; &lt;/p&gt;

&lt;h2&gt;Defining the Environment&lt;/h2&gt;

&lt;p&gt;Environments are a logical grouping of targets / machines used by deployments. For the purpose of this post, I will create one environment - &lt;code&gt;Testing&lt;/code&gt; and it would contain a single CRM deployment target - the CRM Server). &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Let's start off by clicking on the &lt;code&gt;Environments&lt;/code&gt; from the main menu to navigate to the environment configuration page.&lt;/li&gt;
&lt;li&gt;Click on &lt;code&gt;Add environment&lt;/code&gt; in the resulting page.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Set &lt;code&gt;Testing&lt;/code&gt; as the name of the environment .&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/10_create_environment.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Click on &lt;code&gt;Save&lt;/code&gt; to confirm selection.&lt;/li&gt;
&lt;/ol&gt;

</summary><published>2017-04-24T14:00:00Z</published><updated>2017-04-24T14:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-release-part-3/" /><content type="html">&lt;p&gt;In this third and final installment I cover the steps involved in setting up the minimum release and deployment steps required for a successful Dynamics CRM/365 deployment. The steps and actions performed in the previous posts acts as prerequisites for this one.&lt;/p&gt;

&lt;p&gt;Related posts from the series:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-setup-part-1/"&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 1 - Setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-build-part-2/"&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 2 - Build&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 3 - Release and Deployment&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;The Packages&lt;/h2&gt;

&lt;p&gt;In the &lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-build-part-2/"&gt;previous post&lt;/a&gt;, I setup the team build to automatically publish packages into the Octopus Deploy package repository. &lt;/p&gt;

&lt;p&gt;We can verify that they have indeed been published by navigating to the &lt;code&gt;Library &amp;gt; Packages&lt;/code&gt; tab for a list of available packages.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/05_published_package.png" alt="Available Packages" /&gt; &lt;/p&gt;

&lt;h2&gt;Defining the Environment&lt;/h2&gt;

&lt;p&gt;Environments are a logical grouping of targets / machines used by deployments. For the purpose of this post, I will create one environment - &lt;code&gt;Testing&lt;/code&gt; and it would contain a single CRM deployment target - the CRM Server). &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Let's start off by clicking on the &lt;code&gt;Environments&lt;/code&gt; from the main menu to navigate to the environment configuration page.&lt;/li&gt;
&lt;li&gt;Click on &lt;code&gt;Add environment&lt;/code&gt; in the resulting page.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Set &lt;code&gt;Testing&lt;/code&gt; as the name of the environment .&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/10_create_environment.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Click on &lt;code&gt;Save&lt;/code&gt; to confirm selection.&lt;/li&gt;
&lt;/ol&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;Next, define the deployment target for this environment:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Navigate to the Environments summary page and click the &lt;code&gt;Add deployment target&lt;/code&gt; button.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Select &lt;code&gt;Cloud Region&lt;/code&gt; as the deployment target.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/20_deployment_target.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Set &lt;code&gt;Test CRM Server&lt;/code&gt; as the &lt;code&gt;Display name&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Select the previously created &lt;code&gt;Testing&lt;/code&gt; as one of the &lt;code&gt;Environments&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create a new role called &lt;code&gt;crm instance&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/30_deployment_target2.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click on &lt;code&gt;Save&lt;/code&gt; button to confirm.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/40_deployment_target3.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Variable Sets&lt;/h3&gt;

&lt;p&gt;I will be creating a variable set to host all settings required to connect to the CRM Server. It makes configuration easier and also provides us with the ability to reuse the same server in multiple projects.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;From the main menu navigate to &lt;code&gt;Library &amp;gt; Variable Sets&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click on &lt;code&gt;Add variable set&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/50_variables.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Define three new variables:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#{TestCRM-servername}&lt;/code&gt;: The CRM Server Url.  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;#{TestCRM-username}&lt;/code&gt;: The deployment username.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#{TestCRM-password}&lt;/code&gt;: The deployment password. On this one, set the &lt;code&gt;variable type&lt;/code&gt; as &lt;code&gt;Sensitive&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/60_variables_created.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click the &lt;code&gt;Save&lt;/code&gt; button.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Define the Project&lt;/h3&gt;

&lt;p&gt;Projects allow to define a proper release lifecyle by bringing together the different environments and deployment steps. &lt;/p&gt;

&lt;p&gt;Let's define a new project:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Navigate to &lt;code&gt;Projects&lt;/code&gt; menu.&lt;/li&gt;
&lt;li&gt;Click on the &lt;code&gt;Add project&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Provide a name and description. Leave the other options to default.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click on &lt;code&gt;Save&lt;/code&gt; to confirm selection.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/70_create_project.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now associate our previously created variable set as part of our project:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Navigate to the &lt;code&gt;Variable &amp;gt; Library Variable Sets&lt;/code&gt; tab within the project.&lt;/li&gt;
&lt;li&gt;Click the &lt;code&gt;Include variable sets from the Library&lt;/code&gt; button.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Choose the previously created variable set.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/80_include_variable_project.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click the &lt;code&gt;Apply&lt;/code&gt; and then &lt;code&gt;Save&lt;/code&gt; buttons to confirm selection.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/90_include_variable_project2.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Setup the Deployment Process&lt;/h2&gt;

&lt;p&gt;The deployment steps are pretty simple and consists of two PowerShell scripts; the first one is an inline script that sets up the prerequisites while the second one does the actual deployment. &lt;/p&gt;

&lt;h3&gt;Prerequisite script&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Navigate to the &lt;code&gt;Process&lt;/code&gt; tab within the project.&lt;/li&gt;
&lt;li&gt;Click on &lt;code&gt;Add your first step&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Select a &lt;code&gt;Run a Script&lt;/code&gt; template.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/100_step_template.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Update the following parameters while accepting the default selections for the others:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Step name&lt;/code&gt;: &lt;code&gt;Setup Prerequisites&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Run on&lt;/code&gt; : &lt;code&gt;Deployment targets&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Runs on targets in roles&lt;/code&gt; : &lt;code&gt;crm instance&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Script source&lt;/code&gt; : &lt;code&gt;Source code&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Script&lt;/code&gt;: &lt;code&gt;Powershell&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Provide the following for the body of the script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force -Scope CurrentUser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/110_step_1.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click &lt;code&gt;Save&lt;/code&gt; to apply changes.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Deployment Script&lt;/h3&gt;

&lt;p&gt;The steps are very similar to the previous one, but this time we want to execute a script that is already part of the package. &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Once again,click on &lt;code&gt;Add step&lt;/code&gt; and select a &lt;code&gt;Run a Script&lt;/code&gt; template:&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Update the following parameters while accepting the default selections for the others:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Step name&lt;/code&gt;: &lt;code&gt;Deploy CRM Solution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Run on&lt;/code&gt; : &lt;code&gt;Deployment targets&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Runs on targets in roles&lt;/code&gt; : &lt;code&gt;crm instance&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Script source&lt;/code&gt; : &lt;code&gt;Script file inside a package&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Keep the &lt;code&gt;Package Feed&lt;/code&gt; on &lt;code&gt;Octopus Server (built-in)&lt;/code&gt; as we've already published our package into OD.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Set &lt;code&gt;Package ID&lt;/code&gt; to &lt;code&gt;gnxdemo.crm&lt;/code&gt;. This is the name that the build published.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Set the &lt;code&gt;Script file name&lt;/code&gt; value to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Nullfactory.Xrm.Tooling\Scripts\Deploy-CrmSolution.ps1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Set the &lt;code&gt;Script parameters&lt;/code&gt; value to by integrating the variables that we created earlier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-serverUrl "#{TestCRM-servername}" -username "#{TestCRM-username}" -password "#{TestCRM-password}" -solutionName "gnxdemo.crm" -publishChanges -activatePlugins
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/120_step_2.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click the &lt;code&gt;Save&lt;/code&gt; button.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/130_step_summary.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Release and Deployment&lt;/h2&gt;

&lt;p&gt;Now that we have everything setup let's create a new release and then deploy the same to the &lt;code&gt;Testing environment&lt;/code&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Navigate to the Project page.&lt;/li&gt;
&lt;li&gt;Click on the &lt;code&gt;Create Release&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Provide a version number for the new release. I gave it &lt;code&gt;0.0.1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Ensure that the &lt;code&gt;Deploy CRM Solution&lt;/code&gt; step is referencing the latest version of the solution.&lt;/li&gt;
&lt;li&gt;Click on the &lt;code&gt;Save&lt;/code&gt; button the confirm the release. The release page shows an overview of the release including the its lifecyle path and as well as the packages being deployed.&lt;/li&gt;
&lt;li&gt;Click on the &lt;code&gt;Deploy to Testing&lt;/code&gt; in order to deploy the solution to the testing environment.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click the &lt;code&gt;Deploy now&lt;/code&gt; button in the resulting page to kick off the deployment.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/140_deploy_release.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The page would redirect to a summary page showing the progress of the deployment. &lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/150_deploy_task_progress.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click on the &lt;code&gt;Task Log&lt;/code&gt; to view a more verbose view of the solution being deployed.  &lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt3/160_deploy_task_log.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;While I think I have barely scratched the surface of the features provided by Octopus Deploy, the process of writing this series of posts made me appreciate the intuitive structure of key concepts as well as the myriad of options available to support even the most complex of release life cycles. This series also gave me the opportunity to validate the flexibility of the project structure generated using the &lt;a href="https://www.npmjs.com/package/generator-nullfactory-xrm"&gt;generator-nullfactory-xrm&lt;/a&gt; - with its ability to work with different DevOps tools.&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://octopus.com/docs/key-concepts/environments"&gt;Environments - Octopus Deploy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://octopus.com/docs/key-concepts/projects"&gt;Projects - Octopus Deploy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://octopus.com/docs/key-concepts/machine-roles"&gt;Machine Roles - Octopus Deploy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://octopus.com/docs/deployment-targets"&gt;Deployment targets - Octopus Deploy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://octopus.com/docs/deployment-targets/azure-cloud-service-target"&gt;Azure Cloud Service Deployment Targets - Octopus Deploy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-build-part-2/</id><title type="text">Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 2 - Build</title><summary type="html">&lt;p&gt;This is the second part of a series of posts where I attempt to deploy a Dynamics 365/CRM solution using Visual Studio Team Services (VSTS) and Octopus Deploy (OD). Previously, I setup an OD server and integrated it with VSTS - the steps describe in that post act as a prerequisite for this one. In this post we go about modifying an existing Dynamics CRM build definition to automatically package the release-artifact and upload it to the OD server for deployment. &lt;/p&gt;

&lt;p&gt;Related posts from the series:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-setup-part-1/"&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 1 - Setup&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 2 - Build&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-release-part-3/"&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 3 - Release and Deployment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Publishing Packages&lt;/h2&gt;

&lt;p&gt;There are a few different ways of getting a package into Octopus Deploy:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Remotely upload a package to Octopus Deploy's built-in repository.&lt;/li&gt;
&lt;li&gt;Make octopus deploy pull packages from an external feed. Find more information &lt;a href="https://www.visualstudio.com/en-us/docs/package/overview"&gt;here&lt;/a&gt; on setting up VSTS to publish an package feed.&lt;/li&gt;
&lt;li&gt;Manually upload the package into the built-in repository.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And the method of publishing the package has no bearing on the end deployment -I chose to explicitly push to the remote octopus deploy server. &lt;/p&gt;

</summary><published>2017-04-23T14:00:00Z</published><updated>2017-04-23T14:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-build-part-2/" /><content type="html">&lt;p&gt;This is the second part of a series of posts where I attempt to deploy a Dynamics 365/CRM solution using Visual Studio Team Services (VSTS) and Octopus Deploy (OD). Previously, I setup an OD server and integrated it with VSTS - the steps describe in that post act as a prerequisite for this one. In this post we go about modifying an existing Dynamics CRM build definition to automatically package the release-artifact and upload it to the OD server for deployment. &lt;/p&gt;

&lt;p&gt;Related posts from the series:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-setup-part-1/"&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 1 - Setup&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 2 - Build&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-release-part-3/"&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 3 - Release and Deployment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Publishing Packages&lt;/h2&gt;

&lt;p&gt;There are a few different ways of getting a package into Octopus Deploy:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Remotely upload a package to Octopus Deploy's built-in repository.&lt;/li&gt;
&lt;li&gt;Make octopus deploy pull packages from an external feed. Find more information &lt;a href="https://www.visualstudio.com/en-us/docs/package/overview"&gt;here&lt;/a&gt; on setting up VSTS to publish an package feed.&lt;/li&gt;
&lt;li&gt;Manually upload the package into the built-in repository.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And the method of publishing the package has no bearing on the end deployment -I chose to explicitly push to the remote octopus deploy server. &lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;h2&gt;Updating the Build Definition&lt;/h2&gt;

&lt;p&gt;A quick summary of the notable steps in the existing build definition:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt2/10_starting_build_def.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The actual &lt;code&gt;msbuild&lt;/code&gt; command that is being used to build the solution.&lt;/li&gt;
&lt;li&gt;Copy the built artifacts to the staging folder.&lt;/li&gt;
&lt;li&gt;Explicitly Copy Deployment Scripts into the staging folder.&lt;/li&gt;
&lt;li&gt;Delete binaries (such as plugins and workflows) that have already been packaged as part of the solution package. As these serve no purpose in the final drop, I explicitly delete them to reduce the file size.&lt;/li&gt;
&lt;li&gt;Publish the files in the staging folder into the final drop artifact.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Review my previous post on setting up the build definition &lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now let's start implementing the changes to the definition:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Add the &lt;code&gt;Package Application&lt;/code&gt; task.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt2/20_add_package_app.png" alt="Add Package Application Task" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Configure the task by providing the following details:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Package ID&lt;/code&gt; : This is unique identification for the package. I provided &lt;code&gt;gnxdemo.crm&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Package Format&lt;/code&gt; : Choose between NuGet and Zip. I chose NuGet. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Package Version&lt;/code&gt; : Configure this as appropriate. The generated package version should follow a valid SemVer versioning strategy.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Source Path&lt;/code&gt; : Set this to the &lt;code&gt;$(build.artifactstagingdirectory)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Output Path&lt;/code&gt; : Set it to a dedicated folder within the staging directory. I used &lt;code&gt;$(build.artifactstagingdirectory)\OctopusDeploy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt2/30_config_package_app.png" alt="Configure Package Application Task" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, add the &lt;code&gt;Push Package&lt;/code&gt; task.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt2/40_add_push_package.png" alt="Add Push Package Task" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Configure the task by providing the following details:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Octopus Deploy Server&lt;/code&gt; : Choose the available server.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Package&lt;/code&gt;: This is the location of the package file. Since I am only creating a single package I setup the path resolution using a wildcard &lt;code&gt;$(build.artifactstagingdirectory)\OctopusDeploy\*.nupkg&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt2/50_config_package.png" alt="Configure Push Package Task" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Remove the &lt;code&gt;Publish Artifact: drop&lt;/code&gt; task as it is no longer necessary.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt2/60_remove_pushlish_artifacts.png" alt="Remove Publish Artifact Task" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Queue a new build to make sure that everything is in order.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt2/70_queued_build.png" alt="Queue New Build" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Log into the Octopus Deploy admin panel. Navigate to the &lt;code&gt;Library &amp;gt; Packages&lt;/code&gt; and ensure that the package has successfully uploaded.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt2/80_published_package.png" alt="Available Packages" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That completes the changes to the build definition. In the &lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-release-part-3/"&gt;next post&lt;/a&gt; I will go about configuring the environments, project definition and the deployment process within Octopus Deploy.&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://octopus.com/docs/guides/use-the-team-foundation-build-custom-task"&gt;Using the Team Foundation Build Custom Tasks - Octopus Deploy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.visualstudio.com/en-us/docs/package/overview"&gt;Package Management in Team Services and TFS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-setup-part-1/</id><title type="text">Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 1 - Setup</title><summary type="html">&lt;p&gt;I have seen &lt;a href="https://octopus.com/"&gt;Octopus Deploy (OD)&lt;/a&gt; being mentioned frequently in the community but haven't had a chance to play around with it myself. Therefore, I think that attempting to deploy a Dynamics 365/CRM solution using Octopus Deploy seemed like the perfect exercise to learn more about the platform and its features.&lt;/p&gt;

&lt;p&gt;I was curious if there were other developers who have released Dynamics CRM using Octopus Deploy and sure enough there was some one who had &lt;a href="https://www.youtube.com/watch?v=--9u5azwSb4"&gt;already thought of that&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this series of posts I try to cover everything from setting up integration with Visual Studio Team Services(VSTS), updating a build definition to automatically publish itself and then finally setting up a simple release and deployment pipeline.&lt;/p&gt;

&lt;p&gt;Related posts from the series:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 1 - Setup &lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-build-part-2/"&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 2 - Build&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-release-part-3/"&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 3 - Release and Deployment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Prerequisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Project structure and deployment scripts based on &lt;a href="https://www.npmjs.com/package/generator-nullfactory-xrm"&gt;generator-nullfactory-xrm&lt;/a&gt; (with a minimum version of at least 1.4.0). &lt;a href="http://nullfactory.net/2016/10/release-strategy-for-dynamics-crm-prepping-part-1/"&gt;Read More&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The project checked into Visual Studio Team Services (VSTS) using either &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;tfsvc&lt;/code&gt; with a working team build already setup. &lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2"&gt;Read More&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Installation of Octopus Deploy and ensure sure that it is publicly accessible. &lt;a href="https://www.youtube.com/watch?v=T0BQvMDXPNQ"&gt;Read More&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;The Strategy&lt;/h2&gt;

&lt;p&gt;When I saw the integration tasks provided by the OD extensions for VSTS, my first reaction was to divide the tasks between the build and the release in VSTS. I wanted to the the build definition to build and package the solution and pass it on to release management. Release management would then publishing the release-artifact to OD and explicitly remote trigger the OD deployment.&lt;/p&gt;

&lt;p&gt;While it was certainly possible to set this up, its did not make sense to have two deployment services for the same pipeline. Therefore the strategy is going to be very similar to the one that I had done previously - VSTS would continue to act as the version control and build server but this time Octopus deploy would act as the release component.&lt;/p&gt;

&lt;p&gt;The build server would handle creating compatible package and uploading it to the OD package repository. And OD takes over the management of the environment, release and deployment complexities.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt1/05_overview.png" alt="Release Strategy Overview" /&gt;&lt;/p&gt;

</summary><published>2017-04-22T14:00:00Z</published><updated>2017-04-22T14:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-setup-part-1/" /><content type="html">&lt;p&gt;I have seen &lt;a href="https://octopus.com/"&gt;Octopus Deploy (OD)&lt;/a&gt; being mentioned frequently in the community but haven't had a chance to play around with it myself. Therefore, I think that attempting to deploy a Dynamics 365/CRM solution using Octopus Deploy seemed like the perfect exercise to learn more about the platform and its features.&lt;/p&gt;

&lt;p&gt;I was curious if there were other developers who have released Dynamics CRM using Octopus Deploy and sure enough there was some one who had &lt;a href="https://www.youtube.com/watch?v=--9u5azwSb4"&gt;already thought of that&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this series of posts I try to cover everything from setting up integration with Visual Studio Team Services(VSTS), updating a build definition to automatically publish itself and then finally setting up a simple release and deployment pipeline.&lt;/p&gt;

&lt;p&gt;Related posts from the series:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 1 - Setup &lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-build-part-2/"&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 2 - Build&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-release-part-3/"&gt;Deploy Dynamics CRM Solutions using VSTS and Octopus Deploy - Part 3 - Release and Deployment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Prerequisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Project structure and deployment scripts based on &lt;a href="https://www.npmjs.com/package/generator-nullfactory-xrm"&gt;generator-nullfactory-xrm&lt;/a&gt; (with a minimum version of at least 1.4.0). &lt;a href="http://nullfactory.net/2016/10/release-strategy-for-dynamics-crm-prepping-part-1/"&gt;Read More&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The project checked into Visual Studio Team Services (VSTS) using either &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;tfsvc&lt;/code&gt; with a working team build already setup. &lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2"&gt;Read More&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Installation of Octopus Deploy and ensure sure that it is publicly accessible. &lt;a href="https://www.youtube.com/watch?v=T0BQvMDXPNQ"&gt;Read More&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;The Strategy&lt;/h2&gt;

&lt;p&gt;When I saw the integration tasks provided by the OD extensions for VSTS, my first reaction was to divide the tasks between the build and the release in VSTS. I wanted to the the build definition to build and package the solution and pass it on to release management. Release management would then publishing the release-artifact to OD and explicitly remote trigger the OD deployment.&lt;/p&gt;

&lt;p&gt;While it was certainly possible to set this up, its did not make sense to have two deployment services for the same pipeline. Therefore the strategy is going to be very similar to the one that I had done previously - VSTS would continue to act as the version control and build server but this time Octopus deploy would act as the release component.&lt;/p&gt;

&lt;p&gt;The build server would handle creating compatible package and uploading it to the OD package repository. And OD takes over the management of the environment, release and deployment complexities.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt1/05_overview.png" alt="Release Strategy Overview" /&gt;&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;h2&gt;Integrate Octopus Deploy with VSTS&lt;/h2&gt;

&lt;p&gt;Let's start of by integrating OD with VSTS.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Log into the Octopus Deploy admin panel with an user account that has enough permission to generate an API key.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt1/10_od_api_profile.png" alt="API Profile" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click on the &lt;code&gt;Profile&lt;/code&gt; and navigate to the &lt;code&gt;API keys&lt;/code&gt; tab and generate a new API key.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt1/20_generate_new_api_key.png" alt="Generate New API Key" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Copy the newly generated API key. &lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt1/30_api_key.png" alt="API Key" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, log into VSTS using the project collection administrator account.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Install the &lt;a href="https://marketplace.visualstudio.com/items?itemName=octopusdeploy.octopus-deploy-build-release-tasks"&gt;Octopus Deploy Integration&lt;/a&gt; extension.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt1/40_od_integ.png" alt="OD VSTS Integration" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt1/50_od_integ_install_complete.png" alt="Integration Installation Complete" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, we create a OD connected service that would expose the build tasks required by the team build. Let's start off by navigating to the &lt;code&gt;Settings &amp;gt; Services&lt;/code&gt; tab.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Clicking on the &lt;code&gt;New Service Endpoint&lt;/code&gt; under the &lt;code&gt;Endpoints&lt;/code&gt; tab.&lt;/li&gt;
&lt;li&gt;Select &lt;code&gt;Octopus Deploy&lt;/code&gt; from the list.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt1/60_service_endpoint.png" alt="Project structure" /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Provide the details of your OD environment and previously generated API key.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/OctoDeployPt1/70_service_endpoint2.png" alt="Project structure" /&gt;&lt;/p&gt;

&lt;p&gt;Now that the VSTS environment is connected with OD, we move onto working on the build definition. In my &lt;a href="http://nullfactory.net/2017/04/deploy-dynamics-crm-solutions-vsts-octopus-deploy-build-part-2/"&gt;next post&lt;/a&gt; I will go about updating a previously setup build definition to automatically package the solution and publish it to Octopus Deploy. &lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=--9u5azwSb4"&gt;July 2016 Meeting - Automated Deployment in CRM Using Octopus Deploy - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.visualstudio.com/en-us/docs/marketplace/get-vsts-extensions"&gt;Get extensions for Visual Studio Team Services | Visual Studio Team Services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://octopus.com/docs/guides/use-the-team-foundation-build-custom-task"&gt;Using the Team Foundation Build Custom Tasks - Octopus Deploy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://octopus.com/docs/how-to/how-to-create-an-api-key"&gt;How to create an API key - Octopus Deploy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=FOxqnle2bCc"&gt;Octopus 3.0 part 1: Introduction - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=T0BQvMDXPNQ"&gt;Octopus 3.0 part 2: Installing the Octopus Deploy Server - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>http://nullfactory.net/2017/04/version-140-generator-nullfactory-xrm-published/</id><title type="text">Version 1.4.0 of generator-nullfactory-xrm Published</title><summary type="html">&lt;p&gt;Version &lt;code&gt;1.4.0&lt;/code&gt; of the generator released. It includes the following changes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Added support to deploy third-party CRM solutions.&lt;/li&gt;
&lt;li&gt;CRM SDK assemblies updated:
&lt;ul&gt;
&lt;li&gt;Microsoft.CrmSdk.CoreTools &lt;code&gt;8.1.0.2&lt;/code&gt; =&gt; &lt;code&gt;8.2.0.4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Microsoft.CrmSdk.CoreAssemblies &lt;code&gt;8.1.0.2&lt;/code&gt; =&gt; &lt;code&gt;8.2.0.2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Microsoft.CrmSdk.Workflow &lt;code&gt;8.1.0.2&lt;/code&gt; =&gt; &lt;code&gt;8.2.0.2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;If opted-in to generate plugins and workflows projects, the generator would automatically create mapping entries in the &lt;code&gt;mapping-xml&lt;/code&gt; file. &lt;/li&gt;
&lt;li&gt;PowerShell script updates:
&lt;ul&gt;
&lt;li&gt;Better handling of exception and failure flows.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*.param.ps1&lt;/code&gt; scripts to have high verbosity by default.&lt;/li&gt;
&lt;li&gt;Fixed deploy script to have the new solution name. (i.e. &lt;code&gt;ProjectPrefix+SolutionName&lt;/code&gt;) &lt;/li&gt;
&lt;li&gt;Improved help documentation.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

</summary><published>2017-04-17T14:00:00Z</published><updated>2017-04-17T14:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/04/version-140-generator-nullfactory-xrm-published/" /><content type="html">&lt;p&gt;Version &lt;code&gt;1.4.0&lt;/code&gt; of the generator released. It includes the following changes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Added support to deploy third-party CRM solutions.&lt;/li&gt;
&lt;li&gt;CRM SDK assemblies updated:
&lt;ul&gt;
&lt;li&gt;Microsoft.CrmSdk.CoreTools &lt;code&gt;8.1.0.2&lt;/code&gt; =&gt; &lt;code&gt;8.2.0.4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Microsoft.CrmSdk.CoreAssemblies &lt;code&gt;8.1.0.2&lt;/code&gt; =&gt; &lt;code&gt;8.2.0.2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Microsoft.CrmSdk.Workflow &lt;code&gt;8.1.0.2&lt;/code&gt; =&gt; &lt;code&gt;8.2.0.2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;If opted-in to generate plugins and workflows projects, the generator would automatically create mapping entries in the &lt;code&gt;mapping-xml&lt;/code&gt; file. &lt;/li&gt;
&lt;li&gt;PowerShell script updates:
&lt;ul&gt;
&lt;li&gt;Better handling of exception and failure flows.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*.param.ps1&lt;/code&gt; scripts to have high verbosity by default.&lt;/li&gt;
&lt;li&gt;Fixed deploy script to have the new solution name. (i.e. &lt;code&gt;ProjectPrefix+SolutionName&lt;/code&gt;) &lt;/li&gt;
&lt;li&gt;Improved help documentation.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;Please feel free to submit any feature requests or issues found to https://github.com/shanec-/generator-nullfactory-xrm/issues&lt;/p&gt;
</content></entry><entry><id>http://nullfactory.net/2017/04/release-strategy-for-dynamics-crm-deploying-third-party-solutions-part-5/</id><title type="text">Release Strategy for Dynamics CRM - Part 5 - Deploy Third-Party Solutions</title><summary type="html">&lt;p&gt;More often than not the custom Dynamics 365 solutions I develop depend on third party solutions to provide additional functionality. Therefore these solutions become a pre-requisite to the successful deployment of my own solution. &lt;/p&gt;

&lt;p&gt;In this post I go about updating the &lt;a href="http://nullfactory.net/2016/10/release-strategy-for-dynamics-crm-prepping-part-1/"&gt;previously setup project&lt;/a&gt;, &lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2"&gt;build&lt;/a&gt; and &lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-release-part-3/"&gt;release&lt;/a&gt; definitions in Visual Studio Team Services (VSTS) in order to enable deployment of third party CRM solutions.&lt;/p&gt;

&lt;h2&gt;Pre-requisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Project structure and deployment scripts based on &lt;a href="https://www.npmjs.com/package/generator-nullfactory-xrm"&gt;generator-nullfactory-xrm&lt;/a&gt; (with a minimum version of at least 1.4.0).&lt;/li&gt;
&lt;li&gt;A working build and release definitions already setup.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Read more about setting up the project structure and build here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/10/release-strategy-for-dynamics-crm-prepping-part-1/"&gt;Release Strategy for Dynamics CRM - Part 1 - Preparation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2"&gt;Release Strategy for Dynamics CRM - Part 2 - Setting Up the Build&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-release-part-3/"&gt;Release Strategy for Dynamics CRM - Part 3 - Setting Up the Release&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Project Structure&lt;/h2&gt;

&lt;p&gt;I start off by adding a solution level folder to hold third party solutions and  check-in the changes into source control.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmReleasePt5/10_structure.png" alt="Project structure" /&gt;&lt;/p&gt;

</summary><published>2017-04-15T14:00:00Z</published><updated>2017-04-15T14:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/04/release-strategy-for-dynamics-crm-deploying-third-party-solutions-part-5/" /><content type="html">&lt;p&gt;More often than not the custom Dynamics 365 solutions I develop depend on third party solutions to provide additional functionality. Therefore these solutions become a pre-requisite to the successful deployment of my own solution. &lt;/p&gt;

&lt;p&gt;In this post I go about updating the &lt;a href="http://nullfactory.net/2016/10/release-strategy-for-dynamics-crm-prepping-part-1/"&gt;previously setup project&lt;/a&gt;, &lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2"&gt;build&lt;/a&gt; and &lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-release-part-3/"&gt;release&lt;/a&gt; definitions in Visual Studio Team Services (VSTS) in order to enable deployment of third party CRM solutions.&lt;/p&gt;

&lt;h2&gt;Pre-requisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Project structure and deployment scripts based on &lt;a href="https://www.npmjs.com/package/generator-nullfactory-xrm"&gt;generator-nullfactory-xrm&lt;/a&gt; (with a minimum version of at least 1.4.0).&lt;/li&gt;
&lt;li&gt;A working build and release definitions already setup.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Read more about setting up the project structure and build here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/10/release-strategy-for-dynamics-crm-prepping-part-1/"&gt;Release Strategy for Dynamics CRM - Part 1 - Preparation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2"&gt;Release Strategy for Dynamics CRM - Part 2 - Setting Up the Build&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-release-part-3/"&gt;Release Strategy for Dynamics CRM - Part 3 - Setting Up the Release&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Project Structure&lt;/h2&gt;

&lt;p&gt;I start off by adding a solution level folder to hold third party solutions and  check-in the changes into source control.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmReleasePt5/10_structure.png" alt="Project structure" /&gt;&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;h2&gt;Build&lt;/h2&gt;

&lt;p&gt;Next, we update the build to ensure that the solutions are included as part of the build drop. I add a &lt;code&gt;Copy Files&lt;/code&gt; task with the following parameters:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Source Folder&lt;/code&gt;: &lt;code&gt;$(build.sourcesdirectory)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Contents&lt;/code&gt;: &lt;code&gt;**/_prereq-solutions/*.zip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Target Folder&lt;/code&gt;:  &lt;code&gt;$(build.artifactstagingdirectory)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmReleasePt5/20_build.png" alt="Updated build definition" /&gt;&lt;/p&gt;

&lt;p&gt;I trigger a new build to make sure that the solutions are copied over as part of the build artifacts.&lt;/p&gt;

&lt;h2&gt;Release&lt;/h2&gt;

&lt;p&gt;Now that our third-party solutions are included as part of the build drop, its time to deploy them. In this scenario I deploy all the solutions contained within the &lt;code&gt;_prereq-solutions&lt;/code&gt; folder. &lt;/p&gt;

&lt;p&gt;I added a new PowerShell task as a precursor to the main solution deployment. I set it as an &lt;code&gt;inline script&lt;/code&gt; with the following body:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Get-ChildItem "..\..\_prereq-solutions\" -Filter *.zip | 
Foreach-Object {
    .\Deploy-CrmSolution.ps1 -serverUrl "$(sndbxservername)" -username "$(sndbxusername)" -password "$(sndbxpassword)" -externalSolutionFileName $_.FullName -publishChanges -activatePlugins -importAsHoldingSolution:$false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also set the working folder to the &lt;code&gt;Nullfactory.Xrm.Tooling/Scripts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;This script iterates through all the solutions in the folder and attempts to deploy them. &lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmReleasePt5/30_release.png" alt="Updated release definition" /&gt;&lt;/p&gt;

&lt;p&gt;If you have multiple inter-dependent third-party solutions and require them to deployed in particular sequence you can either: &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Add additional PowerShell tasks for each of the solutions.&lt;/li&gt;
&lt;li&gt;Rename the solutions with a ranking number so that the GetChild function orders and execute them implicitly. &lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>http://nullfactory.net/2017/04/special-characters-primary-field-breaks-sharepoint-file-upload/</id><title type="text">Special Characters in Primary Field Breaks SharePoint File Upload in Dynamics 365</title><summary type="html">&lt;p&gt;My colleagues and I ran into this confusing issue the other day. We've been working on a Dynamics 365 Online instance integrated with SharePoint (as a server side configuration) and everything seem to be working as expected but for a few records. On these records, anytime the user hits the upload button in document management they are greeted with the following error message instead of the expected upload dialog:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;An error has occurred. &lt;/p&gt;
  
  &lt;p&gt;Try this action again. If the problem continues, check the Microsoft Dynamics 365 Community for solutions or contact your organization's Microsoft Dynamics 365 Administrator. Finally, you can contact Microsoft Support.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/BrokenSharePointInteg/10_error_dialog.png" alt="Upload Error Dialog" /&gt;&lt;/p&gt;

</summary><published>2017-04-13T14:00:00Z</published><updated>2017-04-13T14:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/04/special-characters-primary-field-breaks-sharepoint-file-upload/" /><content type="html">&lt;p&gt;My colleagues and I ran into this confusing issue the other day. We've been working on a Dynamics 365 Online instance integrated with SharePoint (as a server side configuration) and everything seem to be working as expected but for a few records. On these records, anytime the user hits the upload button in document management they are greeted with the following error message instead of the expected upload dialog:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;An error has occurred. &lt;/p&gt;
  
  &lt;p&gt;Try this action again. If the problem continues, check the Microsoft Dynamics 365 Community for solutions or contact your organization's Microsoft Dynamics 365 Administrator. Finally, you can contact Microsoft Support.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/BrokenSharePointInteg/10_error_dialog.png" alt="Upload Error Dialog" /&gt;&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;When I navigated to the physical location on the SharePoint server, I can see that a folder record was created successfully in the Document Library and that the logged user has permission to make changes to the folder and its contents. &lt;/p&gt;

&lt;p&gt;Next, I tried manually uploading a document through the SharePoint server and in order to verify that the document was reflected back in the CRM integration component. This too was successful and I verified that it has the ability to perform CRUD operations as expected. &lt;/p&gt;

&lt;p&gt;None of these seemed to get me closer to identifying the issue - the upload control in CRM was still broken for the record.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/BrokenSharePointInteg/20_sharepointfolder.png" alt="SharePoint Folder" /&gt;&lt;/p&gt;

&lt;h2&gt;The Solution&lt;/h2&gt;

&lt;p&gt;With a little bit of trial and error we were finally able to narrow down the issue - it turned out to be the value of the primary field of the record. &lt;/p&gt;

&lt;p&gt;By default, the integration component uses the value of the primary field in order to generate a unique folder name in SharePoint, it takes parts of the name and then appends a unique salt to the end. &lt;/p&gt;

&lt;p&gt;So the problem in our broken record set was that the primary field value contained special characters. While the folder creation itself appears to have cleaned out the these characters, the upload control still did not like it. &lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/BrokenSharePointInteg/30_folder_invalid_chars.png" alt="SharePoint folder invalid characters" /&gt;&lt;/p&gt;

&lt;p&gt;Therefore, the fix itself pretty simple - remove the invalid characters from the primary field and the upload control started working as expected.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/BrokenSharePointInteg/40_validfolder.png" alt="valid SharePoint Folder" /&gt;&lt;/p&gt;

&lt;p&gt;This issue appears to exists as of &lt;code&gt;Microsoft Dynamics 365 Version 1612 (8.2.1.164) (DB 8.2.1.164) online&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I can think of two ways we can avoid this in the future:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Add validation on the primary field to explicitly filter out the special characters - this is the most sensible approach until Microsoft fixes the upload control.&lt;/li&gt;
&lt;li&gt;Handle the creation of the SharePointLocation record and the physical SharePoint folder yourself - this is obviously more work, but provides you more granular control.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I hope this helps anyone else who might encounter this issue.&lt;/p&gt;
</content></entry><entry><id>http://nullfactory.net/2017/04/slide-deck-melbourne-ug/</id><title type="text">Source Control and Release Management - Presentation Slide Deck</title><summary type="html">&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MelbUGSlideDeck/10_TypicalLifeCycle.png" alt="Typical Life Cylce Slide" /&gt;&lt;/p&gt;

&lt;p&gt;A few weeks back, I did a presentation on &lt;code&gt;Source Control and Release Management Strategy for Dynamics 365 Solutions&lt;/code&gt; at the Melbourne Dynamics 365 User Group. Here is the slide deck for that presentation:&lt;/p&gt;

</summary><published>2017-04-11T14:00:00Z</published><updated>2017-04-11T14:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/04/slide-deck-melbourne-ug/" /><content type="html">&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MelbUGSlideDeck/10_TypicalLifeCycle.png" alt="Typical Life Cylce Slide" /&gt;&lt;/p&gt;

&lt;p&gt;A few weeks back, I did a presentation on &lt;code&gt;Source Control and Release Management Strategy for Dynamics 365 Solutions&lt;/code&gt; at the Melbourne Dynamics 365 User Group. Here is the slide deck for that presentation:&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;&lt;a href="https://www.slideshare.net/shanec_/source-control-and-release-strategy-for-dynamics-365-solutions"&gt;https://www.slideshare.net/shanec_/source-control-and-release-strategy-for-dynamics-365-solutions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As always, feel free to reach me through social media if you have any questions.&lt;/p&gt;
</content></entry><entry><id>http://nullfactory.net/2017/02/release-strategy-for-dynamics-crm-versioning-part-4/</id><title type="text">Release Strategy for Dynamics CRM - Part 4 - Versioning</title><summary type="html">&lt;p&gt;In this post I detail my approach to implement an automated versioning strategy in CRM solutions and its custom assemblies with the help of Visual Studio Team Services.&lt;/p&gt;

&lt;p&gt;Although I originally only intended it to be a 3 part series I think I will continue to add to it as I keep making improvements. To recap, I previously prepared the project structure to host a CRM solution with the aid of the &lt;code&gt;nullfactory-xrm&lt;/code&gt; &lt;a href="https://www.npmjs.com/package/generator-nullfactory-xrm"&gt;generator&lt;/a&gt; and created a build and release definitions for it. You can find the previous posts here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/10/release-strategy-for-dynamics-crm-prepping-part-1/"&gt;Release Strategy for Dynamics CRM - Part 1 - Preparation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2"&gt;Release Strategy for Dynamics CRM - Part 2 - Setting Up the Build&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-release-part-3/"&gt;Release Strategy for Dynamics CRM - Part 3 - Setting Up the Release&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Release Strategy for Dynamics CRM - Part 4 - Versioning&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There were two aspects of versioning that I wanted to automatically increment with each release. Firstly the CRM Solution itself and then the custom assemblies included as part of the solution. I also wanted the flexibility to version the two independently of each other (I don't think its a very common scenario, but I would still like to have it as an available option).&lt;/p&gt;

&lt;p&gt;As with my previous posts, the instructions in this are specific to Visual Studio Team Services (VSTS), but can be adapted to work with other build and release systems. &lt;/p&gt;

</summary><published>2017-02-06T13:00:00Z</published><updated>2017-02-06T13:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/02/release-strategy-for-dynamics-crm-versioning-part-4/" /><content type="html">&lt;p&gt;In this post I detail my approach to implement an automated versioning strategy in CRM solutions and its custom assemblies with the help of Visual Studio Team Services.&lt;/p&gt;

&lt;p&gt;Although I originally only intended it to be a 3 part series I think I will continue to add to it as I keep making improvements. To recap, I previously prepared the project structure to host a CRM solution with the aid of the &lt;code&gt;nullfactory-xrm&lt;/code&gt; &lt;a href="https://www.npmjs.com/package/generator-nullfactory-xrm"&gt;generator&lt;/a&gt; and created a build and release definitions for it. You can find the previous posts here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/10/release-strategy-for-dynamics-crm-prepping-part-1/"&gt;Release Strategy for Dynamics CRM - Part 1 - Preparation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2"&gt;Release Strategy for Dynamics CRM - Part 2 - Setting Up the Build&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-release-part-3/"&gt;Release Strategy for Dynamics CRM - Part 3 - Setting Up the Release&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Release Strategy for Dynamics CRM - Part 4 - Versioning&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There were two aspects of versioning that I wanted to automatically increment with each release. Firstly the CRM Solution itself and then the custom assemblies included as part of the solution. I also wanted the flexibility to version the two independently of each other (I don't think its a very common scenario, but I would still like to have it as an available option).&lt;/p&gt;

&lt;p&gt;As with my previous posts, the instructions in this are specific to Visual Studio Team Services (VSTS), but can be adapted to work with other build and release systems. &lt;/p&gt;

&lt;!--excerpt--&gt; 

&lt;h2&gt;Pre-requisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Ideally, a solution structure generated using version 1.3 (or better) of the &lt;code&gt;nullfactory-xrm&lt;/code&gt; generator as the template includes the versioning script as part of it - for the sake of simplicity, the post assumes that this is true. &lt;a href="http://nullfactory.net/2016/10/release-strategy-for-dynamics-crm-prepping-part-1/"&gt;More Info.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;All solution and custom code artifacts and checked-in into source control in VSTS. &lt;/li&gt;
&lt;li&gt;Basic build definition that builds the artifacts and generates a CRM solution using the &lt;code&gt;SolutionPackager.exe&lt;/code&gt;. &lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2"&gt;More info&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Integrating with the Team Build&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Start off by creating a standard build definition for the solution as described in &lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2"&gt;Part 2&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmReleasePt4/10_BuildDefinition.png" alt="Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next we need to define a pair of variables for each set of version numbers we want to maintain. In this scenario I only want one version number to be shared between the custom assemblies and CRM solution. Let's do this by navigating to the &lt;code&gt;Variables&lt;/code&gt; tab and creating the &lt;code&gt;SuperSolutionMajorVersion&lt;/code&gt; and &lt;code&gt;SuperSolutionMinorVersion&lt;/code&gt; variables.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmReleasePt4/20_DefineBuildVariables.png" alt="Define Build Variables" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I want to keep the artifact build number consistent with the name of the actual build, so navigate to the &lt;code&gt;General&lt;/code&gt; tab and set the &lt;code&gt;Build number format&lt;/code&gt; to &lt;code&gt;$(SuperSolutionMajorVersion).$(SuperSolutionMinorVersion).$(Build.BuildId).0&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;Notice that I intentionally hard coded the release version to &lt;code&gt;0&lt;/code&gt;. Tweak this format to suit your own needs, but ensure that the number generated is compatible with the versioning scheme used by CRM - &lt;em&gt;major.minor.build.release&lt;/em&gt; or &lt;em&gt;year.month.day.revision&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmReleasePt4/30_SetBuildNumberFormat.png" alt="Set Build Number Format" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create a PowerShell task which invokes the &lt;code&gt;ApplyVersionToArtifact.ps1&lt;/code&gt; against the assemblies.&lt;/p&gt;

&lt;p&gt;.\Nullfactory.Xrm.Tooling\scripts\ApplyVersionToArtifact.ps1&lt;/p&gt;

&lt;p&gt;ApplyVersionToAssemblies -BuildSourcePath $(Build.SourcesDirectory) -BuildBuildNumber "$(SuperSolutionMajorVersion).$(SuperSolutionMinorVersion).$(Build.BuildId).0"&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmReleasePt4/40_AssemblyPowerShell.png" alt="Apply Assembly Version PowerShell" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Similarly create a second PowerShell task that applies the version number to the CRM Solution.&lt;/p&gt;

&lt;p&gt;. .\Nullfactory.Xrm.Tooling\Scripts\ApplyVersionToArtifact.ps1&lt;/p&gt;

&lt;p&gt;ApplyVersionToCrmSolution -BuildSourcePath $(Build.SourcesDirectory) -BuildBuildNumber "$(SuperSolutionMajorVersion).$(SuperSolutionMinorVersion).$(Build.BuildId).0"&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmReleasePt4/50_SolutionPowerShell.png" alt="Apply Crm Solution Version PowerShell" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Finally, lets queue a new build to make sure that everything works as expected. In the Queue build dialog, manually provide a Major and Minor version for the new release. The Major and Minor versions would act as the "public product" number, were as the build number would be the actual iteration.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmReleasePt4/55_QueueBuild.png" alt="Queue New Build" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Verify that the build completed successfully - notice that it created using new build number formatting.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmReleasePt4/60_BuildResult.png" alt="Build Results" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Open up the packaged solution and verify that the &lt;code&gt;Solution.xml&lt;/code&gt; has the updated version number. Also ensure that the assembly within the solution has been updated as well.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmReleasePt4/70_SolutionXml.png" alt="Empty release template" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;While there were many implementations on the web I based mine off this one &lt;a href="https://github.com/cilerler/rupen/blob/dea035c6e6158abc7a6e449b931ae316c0ef2eb8/build.vso/ApplyVersionToAssemblies.ps1"&gt;https://github.com/cilerler/rupen/blob/dea035c6e6158abc7a6e449b931ae316c0ef2eb8/build.vso/ApplyVersionToAssemblies.ps1&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;If the project structure was not generated using the &lt;code&gt;nullfactory-xrm&lt;/code&gt; generator, then &lt;a href="https://github.com/shanec-/generator-nullfactory-xrm/blob/master/generators/app/templates/Nullfactory.Xrm.Tooling/Scripts/ApplyVersionToArtifact.ps1"&gt;download the latest version&lt;/a&gt; of the &lt;code&gt;ApplyVersionToAssemblies.ps1&lt;/code&gt;script into your own project structure. &lt;/p&gt;

&lt;p&gt;The versioning script can be run manually on developers machine, but its most effective when used together with an automated build and release suite like VSTS. &lt;/p&gt;

&lt;p&gt;I had considered using a tokenization as a possible approach to replacing the version numbers, but the problem with that is that &lt;code&gt;solution packager&lt;/code&gt; does not like tokens embedded in the &lt;code&gt;solution.xml&lt;/code&gt; file. This means that a developer cannot build the solution in their own development environment.&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/cilerler/rupen/blob/dea035c6e6158abc7a6e449b931ae316c0ef2eb8/build.vso/ApplyVersionToAssemblies.ps1"&gt;rupen/ApplyVersionToAssemblies.ps1 at dea035c6e6158abc7a6e449b931ae316c0ef2eb8 · cilerler/rupen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://msdn.microsoft.com/en-us/library/mt593040.aspx"&gt;Create patches to simplify solution updates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://community.dynamics.com/crm/f/117/t/151258"&gt;Solution versioning best practice - Microsoft Dynamics CRM Community Forum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://journeyintocrm.com/archives/1092"&gt;Hardcore CRM: Do a major upgrade of a plugin version! | Journey into CRM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://crmbusiness.wordpress.com/2014/03/31/crm-2013-overview-of-solutions/"&gt;CRM 2013 – Understanding Solutions and how they work – Hosk's Dynamic CRM Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://chamindac.blogspot.com.au/2015/12/apply-build-number-to-assembly-version.html"&gt;Chaminda's Blog: Apply Build Number to Assembly Version with New TFS Builds (Build vNext)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://intovsts.net/2015/08/24/tfs-build-2015-and-versioning/"&gt;TFS Build 2015 … and versioning! | Into ALM with TFS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/pietergheysens/14d7d98547fe35470d0e"&gt;GitHub Gist - Update-AssemblyInfoVersionFiles.ps1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tfsbuildextensions/CustomActivities/blob/master/Source/Scripts/ApplyVersionToAssemblies.ps1"&gt;CustomActivities/ApplyVersionToAssemblies.ps1 at master · tfsbuildextensions/CustomActivities&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=ms-devlabs.utilitytasks"&gt;Release Management Utility tasks - Visual Studio Marketplace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>http://nullfactory.net/2016/11/scheduling-the-uptime-of-an-azure-virtual-machine/</id><title type="text">Scheduling the Uptime of an Azure Virtual Machine</title><summary type="html">&lt;p&gt;In a previous post I setup a &lt;a href="http://nullfactory.net/2016/11/setting-up-a-private-build-agent-in-visual-studio-team-services/"&gt;build agent in a private pipeline&lt;/a&gt; - hosted within a Azure Virtual Machine (VM). In this one, I try to minimize the uptime of the VM by making it run only during work hours - I require it to start automatically first thing in the morning and then turn itself off at the close of business. In order to achieve this I make use of the &lt;a href="https://azure.microsoft.com/en-au/services/automation/"&gt;Azure Automation&lt;/a&gt; feature.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Let's start off by logging into our Azure account and creating a new &lt;code&gt;Automation Account&lt;/code&gt; entry. &lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/10_Automation.png" alt="Search Automation Account" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/20_CreateAutomation.png" alt="Create Automation Account" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Provide the required details:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt; - Name for the automation account.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Subscription&lt;/code&gt; - Azure subscription for this account.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Resource Group&lt;/code&gt; - Create or select an existing resource group from the list. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Location&lt;/code&gt; - Select an available region from the list.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Create Azure Run As account&lt;/code&gt; - Select &lt;code&gt;Yes&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/30_AddAutomationInfo.png" alt="Add Automation Account" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click the &lt;code&gt;Create&lt;/code&gt; button to start provisioning the automation account.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Once done, navigate to it's blade via the resource groups and click on the &lt;code&gt;Runbooks&lt;/code&gt; widget.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/40_CreateRunbook.png" alt="Create runbook" /&gt;&lt;/p&gt;

</summary><published>2016-11-27T13:00:00Z</published><updated>2016-11-27T13:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2016/11/scheduling-the-uptime-of-an-azure-virtual-machine/" /><content type="html">&lt;p&gt;In a previous post I setup a &lt;a href="http://nullfactory.net/2016/11/setting-up-a-private-build-agent-in-visual-studio-team-services/"&gt;build agent in a private pipeline&lt;/a&gt; - hosted within a Azure Virtual Machine (VM). In this one, I try to minimize the uptime of the VM by making it run only during work hours - I require it to start automatically first thing in the morning and then turn itself off at the close of business. In order to achieve this I make use of the &lt;a href="https://azure.microsoft.com/en-au/services/automation/"&gt;Azure Automation&lt;/a&gt; feature.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Let's start off by logging into our Azure account and creating a new &lt;code&gt;Automation Account&lt;/code&gt; entry. &lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/10_Automation.png" alt="Search Automation Account" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/20_CreateAutomation.png" alt="Create Automation Account" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Provide the required details:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt; - Name for the automation account.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Subscription&lt;/code&gt; - Azure subscription for this account.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Resource Group&lt;/code&gt; - Create or select an existing resource group from the list. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Location&lt;/code&gt; - Select an available region from the list.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Create Azure Run As account&lt;/code&gt; - Select &lt;code&gt;Yes&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/30_AddAutomationInfo.png" alt="Add Automation Account" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click the &lt;code&gt;Create&lt;/code&gt; button to start provisioning the automation account.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Once done, navigate to it's blade via the resource groups and click on the &lt;code&gt;Runbooks&lt;/code&gt; widget.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/40_CreateRunbook.png" alt="Create runbook" /&gt;&lt;/p&gt;

&lt;!--excerpt--&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The runbook gallery had a couple of really good graphical runbooks that suited my purposes - the &lt;code&gt;Start Azure V2 VMs&lt;/code&gt; and &lt;code&gt;Stop Azure V2 VMs&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;Click on the &lt;code&gt;Browse Gallery&lt;/code&gt; button, select the &lt;code&gt;Start Azure V2 VMs&lt;/code&gt; graphical runbook and then click &lt;code&gt;OK&lt;/code&gt; to confirm the selection.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/50_ChooseRecipe.png" alt="Choose Graphical Runbook" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Inspect the flow and click the &lt;code&gt;Import&lt;/code&gt; button when ready.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/60_ImportRecipe.png" alt="Import Graphical Runbook" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Navigate into the newly added runbook and click the &lt;code&gt;Edit&lt;/code&gt; button. Make any alterations if required and click the &lt;code&gt;Publish&lt;/code&gt; button.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/70_PublishRunbook.png" alt="Publish Runbook" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Back on the runbook blade, click on &lt;code&gt;Schedules&lt;/code&gt; widget and then click on the &lt;code&gt;Add a schedule&lt;/code&gt; button.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/80_AddSchedule.png" alt="Add Schedule" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click on the &lt;code&gt;Link a schedule to your runbook&lt;/code&gt; and then create a new schedule. Provide the time and recurrence for the script execution. &lt;a href="https://docs.microsoft.com/en-au/azure/automation/automation-scheduling-a-runbook"&gt;Read more about scheduling here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/90_FinalizeSchedule.png" alt="Finalize Schedule" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, select &lt;code&gt;Configure parameters and run settings&lt;/code&gt; and provide a virtual machine name or resource group which would start on execution.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/AzureVmSchedule/100_Parameters.png" alt="Schedule parameters" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click the &lt;code&gt;ok&lt;/code&gt; button once done. You should get a confirmation that the schedule is linked to a runbook. &lt;/p&gt;

&lt;p&gt;That's it. The runbook would execute at the pre-defined time.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Repeat the above steps again to create a stop script using the &lt;code&gt;Stop Azure V2 VMs&lt;/code&gt; graphical runbook. &lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://azure.microsoft.com/en-au/services/automation/"&gt;Automation – Cloud process &amp;amp; workflow automation | Microsoft Azure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-au/azure/automation/automation-scheduling-a-runbook"&gt;Scheduling a runbook in Azure Automation | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry></feed>