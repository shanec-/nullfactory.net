<feed xmlns="http://www.w3.org/2005/Atom"><title type="text">nullfactory.net</title><subtitle type="text">nullfactory.net</subtitle><id>http://nullfactory.net/</id><updated>2018-06-12T21:25:06+10:00</updated><author><name>Shane Carvalho</name><uri>http://nullfactory.net</uri><email>shanec_@hotmail.com</email></author><generator>Sandra.Snow Atom Generator</generator><link rel="alternate" href="http://nullfactory.net/feed.xml" /><link rel="self" type="text/html" title="nullfactory.net" href="http://nullfactory.net/feed.xml" /><entry><id>http://nullfactory.net/2018/03/yaml-build-support-for-generator-nullfactory-xrm/</id><title type="text">YAML Build Support for generator-nullfactory-xrm</title><summary type="html">&lt;p&gt;If you've read my previous posts on the topic, you might have already guessed that I am a big fan of maintaining builds as code artefacts. I was super excited when the Visual Studio Team Services (VSTS) team announced YAML support and I knew right then that this had to be part of &lt;code&gt;generator-nullfactory-xrm&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;With version &lt;code&gt;1.6.0&lt;/code&gt;, I've added the ability to generate tailored YAML build definitions into your Dynamics 365 projects. What this means is that you get rich CI build support right out of the gate! No more excuses for not having a CI build in your project!&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildGeneratorSupport/hero.jpg" alt="CI Builds for Everyone" /&gt;&lt;/p&gt;

&lt;p&gt;The option to generate a CI build is defined as a sub-generator. This is intentional as I didn't want to automatically assume that everyone would be using VSTS as their source control.&lt;/p&gt;

&lt;p&gt;Here's the quick rundown of the steps necessary to get things up and running. What we're aiming for is a layered approach:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;First generate the default project structure.&lt;/li&gt;
&lt;li&gt;Next, generate the YML file using a sub-generator.&lt;/li&gt;
&lt;li&gt;Push changes to remote VSTS &lt;code&gt;git&lt;/code&gt; repository.&lt;/li&gt;
&lt;li&gt;Verify that VSTS provisioned the YML file as the CI build.&lt;/li&gt;
&lt;li&gt;... &lt;/li&gt;
&lt;li&gt;Profit!&lt;/li&gt;
&lt;/ol&gt;

</summary><published>2018-03-02T13:00:00Z</published><updated>2018-03-02T13:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2018/03/yaml-build-support-for-generator-nullfactory-xrm/" /><content type="html">&lt;p&gt;If you've read my previous posts on the topic, you might have already guessed that I am a big fan of maintaining builds as code artefacts. I was super excited when the Visual Studio Team Services (VSTS) team announced YAML support and I knew right then that this had to be part of &lt;code&gt;generator-nullfactory-xrm&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;With version &lt;code&gt;1.6.0&lt;/code&gt;, I've added the ability to generate tailored YAML build definitions into your Dynamics 365 projects. What this means is that you get rich CI build support right out of the gate! No more excuses for not having a CI build in your project!&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildGeneratorSupport/hero.jpg" alt="CI Builds for Everyone" /&gt;&lt;/p&gt;

&lt;p&gt;The option to generate a CI build is defined as a sub-generator. This is intentional as I didn't want to automatically assume that everyone would be using VSTS as their source control.&lt;/p&gt;

&lt;p&gt;Here's the quick rundown of the steps necessary to get things up and running. What we're aiming for is a layered approach:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;First generate the default project structure.&lt;/li&gt;
&lt;li&gt;Next, generate the YML file using a sub-generator.&lt;/li&gt;
&lt;li&gt;Push changes to remote VSTS &lt;code&gt;git&lt;/code&gt; repository.&lt;/li&gt;
&lt;li&gt;Verify that VSTS provisioned the YML file as the CI build.&lt;/li&gt;
&lt;li&gt;... &lt;/li&gt;
&lt;li&gt;Profit!&lt;/li&gt;
&lt;/ol&gt;

&lt;!--excerpt--&gt;

&lt;h2&gt;Prerequisites&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Opt-in to the preview build feature in VSTS. &lt;a href="http://nullfactory.net/2018/01/build-pipeline-as-code-yaml-based-ci-build-for-dynamics-365-solutions/"&gt;Read my previous post&lt;/a&gt; on how to do this.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fair warning that as of writing this post, the YAML builds feature within VSTS is still in preview. While very unlikely, there's always the possibility that things might break due to future change.&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A &lt;code&gt;git&lt;/code&gt; based repository in VSTS - YAML builds only work with git repositories.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;The Setup&lt;/h2&gt;

&lt;p&gt;Assumption that nullfactory-xrm generator and &lt;a href="http://yeoman.io/"&gt;Yeoman&lt;/a&gt; itself has alredy been installed on the client computer being worked on and that a Dynamics CRM solution is ready to be synced.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Setup the project using &lt;code&gt;generator-nullfactory-xrm&lt;/code&gt; using the default generator. &lt;a href="http://nullfactory.net/2016/10/release-strategy-for-dynamics-crm-prepping-part-1/"&gt;Read this post&lt;/a&gt; for more detail steps.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yo nullfactory-xrm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildGeneratorSupport/10_defaultgenerator.png" alt="Default Generator" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, run the generator once more from the same folder location, and this time let's use the &lt;code&gt;cibuild&lt;/code&gt; sub-generator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yo nullfactory-xrm:cibuild
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Provide the same solution name you provided in step 1. And choose &lt;code&gt;Visual Studio Team Services&lt;/code&gt; as the type of source control being used.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildGeneratorSupport/20_generatecibuild.png" alt="Default Generator" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This would have generated a file called &lt;code&gt;.vsts-ci.yml&lt;/code&gt;. And that's it - once your changes are checked in and pushed to VSTS, the YML file would be automatically provisioned as the default CI build.&lt;/p&gt;
</content></entry><entry><id>http://nullfactory.net/2018/03/generator-nullfactory-xrm-1-6-0-released/</id><title type="text">generator-nullfactory-xrm 1.6.0 Released!</title><summary type="html">&lt;p&gt;I just &lt;a href="https://www.npmjs.com/package/generator-nullfactory-xrm"&gt;released&lt;/a&gt; version &lt;code&gt;1.6.0&lt;/code&gt; of &lt;code&gt;generator-nullfactory-xrm&lt;/code&gt;. This release includes the following changes:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/generator160/hero.png" alt="generator-nullfactory-xrm" /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;V9 Support!&lt;/li&gt;
&lt;li&gt;Simplified post installation steps with the introduction of &lt;code&gt;_RunFirst.ps1&lt;/code&gt; script.&lt;/li&gt;
&lt;li&gt;Generate VSTS compatible YML build file:
&lt;ul&gt;
&lt;li&gt;Added &lt;code&gt;nullfactory-xrm:cibuild&lt;/code&gt; sub-command.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Generate individual CRM project file post initial scaffolding:
&lt;ul&gt;
&lt;li&gt;Added &lt;code&gt;nullfactory-xrm:solution&lt;/code&gt; sub-command. &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Default generator creates a tailored &lt;code&gt;README.md&lt;/code&gt; file with a summary of changes.&lt;/li&gt;
&lt;li&gt;Fixed issue with generated workflow template code.&lt;/li&gt;
&lt;li&gt;CRM SDK assemblies updated:
&lt;ul&gt;
&lt;li&gt;Microsoft.CrmSdk.CoreTools &lt;code&gt;8.2.0.4&lt;/code&gt; =&gt; &lt;code&gt;9.0.0.7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Microsoft.CrmSdk.CoreAssemblies &lt;code&gt;8.1.0.2&lt;/code&gt; =&gt; &lt;code&gt;9.0.0.7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Microsoft.CrmSdk.Workflow &lt;code&gt;8.1.0.2&lt;/code&gt; =&gt;  &lt;code&gt;9.0.0.7&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Added (Beta) version of the Online Management API scripts.&lt;/li&gt;
&lt;/ul&gt;

</summary><published>2018-02-28T13:00:00Z</published><updated>2018-02-28T13:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2018/03/generator-nullfactory-xrm-1-6-0-released/" /><content type="html">&lt;p&gt;I just &lt;a href="https://www.npmjs.com/package/generator-nullfactory-xrm"&gt;released&lt;/a&gt; version &lt;code&gt;1.6.0&lt;/code&gt; of &lt;code&gt;generator-nullfactory-xrm&lt;/code&gt;. This release includes the following changes:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/generator160/hero.png" alt="generator-nullfactory-xrm" /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;V9 Support!&lt;/li&gt;
&lt;li&gt;Simplified post installation steps with the introduction of &lt;code&gt;_RunFirst.ps1&lt;/code&gt; script.&lt;/li&gt;
&lt;li&gt;Generate VSTS compatible YML build file:
&lt;ul&gt;
&lt;li&gt;Added &lt;code&gt;nullfactory-xrm:cibuild&lt;/code&gt; sub-command.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Generate individual CRM project file post initial scaffolding:
&lt;ul&gt;
&lt;li&gt;Added &lt;code&gt;nullfactory-xrm:solution&lt;/code&gt; sub-command. &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Default generator creates a tailored &lt;code&gt;README.md&lt;/code&gt; file with a summary of changes.&lt;/li&gt;
&lt;li&gt;Fixed issue with generated workflow template code.&lt;/li&gt;
&lt;li&gt;CRM SDK assemblies updated:
&lt;ul&gt;
&lt;li&gt;Microsoft.CrmSdk.CoreTools &lt;code&gt;8.2.0.4&lt;/code&gt; =&gt; &lt;code&gt;9.0.0.7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Microsoft.CrmSdk.CoreAssemblies &lt;code&gt;8.1.0.2&lt;/code&gt; =&gt; &lt;code&gt;9.0.0.7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Microsoft.CrmSdk.Workflow &lt;code&gt;8.1.0.2&lt;/code&gt; =&gt;  &lt;code&gt;9.0.0.7&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Added (Beta) version of the Online Management API scripts.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;Please feel free to submit any feature requests or issues found to &lt;a href="https://github.com/shanec-/generator-nullfactory-xrm/issues"&gt;https://github.com/shanec-/generator-nullfactory-xrm/issues&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Read more about the Dynamics 365 release strategy and how everything fits together:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/10/release-strategy-for-dynamics-crm-prepping-part-1/"&gt;Release Strategy for Dynamics CRM - Part 1 - Preparation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2"&gt;Release Strategy for Dynamics CRM - Part 2 - Setting Up the Build&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-release-part-3/"&gt;Release Strategy for Dynamics CRM - Part 3 - Setting Up the Release&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2017/02/release-strategy-for-dynamics-crm-versioning-part-4/"&gt;Release Strategy for Dynamics CRM - Part 4 - Versioning&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>http://nullfactory.net/2018/02/yaml-builds-and-branches-visual-studio-team-services/</id><title type="text">YAML Builds and Branching in Visual Studio Team Services</title><summary type="html">&lt;p&gt;In my previous post I explored the the concept of treating build as a first class code citizen and how to automatically setup up an YAML based continuous integration (CI) build in Visual Studio Team Services (VSTS). &lt;/p&gt;

&lt;p&gt;At the end of that exercise I was curious as to how VSTS handles build definitions when you throw branching into the mix. I could not find much information on the topic, so I thought I might try it out myself.&lt;/p&gt;

&lt;h2&gt;Branches and CI Builds&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Prepare the project structure place the you build definition &lt;code&gt;.vsts-ci.yml&lt;/code&gt; in the root of the repository. Read &lt;a href="http://nullfactory.net/2018/01/build-pipeline-as-code-yaml-based-ci-build-for-dynamics-365-solutions/"&gt;my previous post&lt;/a&gt; for setting up an exported CI build.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add an echo step so we can uniquely identify this build branch.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/5_TriggeredEchoMaster.png" alt="Triggered Echo" /&gt;&lt;/p&gt;

</summary><published>2018-02-17T13:00:00Z</published><updated>2018-02-17T13:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2018/02/yaml-builds-and-branches-visual-studio-team-services/" /><content type="html">&lt;p&gt;In my previous post I explored the the concept of treating build as a first class code citizen and how to automatically setup up an YAML based continuous integration (CI) build in Visual Studio Team Services (VSTS). &lt;/p&gt;

&lt;p&gt;At the end of that exercise I was curious as to how VSTS handles build definitions when you throw branching into the mix. I could not find much information on the topic, so I thought I might try it out myself.&lt;/p&gt;

&lt;h2&gt;Branches and CI Builds&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Prepare the project structure place the you build definition &lt;code&gt;.vsts-ci.yml&lt;/code&gt; in the root of the repository. Read &lt;a href="http://nullfactory.net/2018/01/build-pipeline-as-code-yaml-based-ci-build-for-dynamics-365-solutions/"&gt;my previous post&lt;/a&gt; for setting up an exported CI build.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add an echo step so we can uniquely identify this build branch.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/5_TriggeredEchoMaster.png" alt="Triggered Echo" /&gt;&lt;/p&gt;

&lt;!--excerpt--&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Commit changes to the &lt;code&gt;master&lt;/code&gt; branch and push it to the remote repository.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Verify that VSTS picked up the build and provisioned the CI build as expected. And that it triggered an initial build.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/10_BuildProvisioned.png" alt="Build Provisioned" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Verify that our echo statement worked.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/15_BuildEchoStatement.png" alt="Build Echo Statement" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now let's update the build trigger to include all feature branches we create. Edit the build definition and navigate to the triggers tab add the following branch filter: &lt;code&gt;features/*&lt;/code&gt;. This means that the build would trigger on each of the &lt;code&gt;feature/&lt;/code&gt; topic branches.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/20_EditBuildDefinition.png" alt="Edit Build Definition" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Navigate to the triggers tab and add a new branch filter.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/30_AddBranchFilter.png" alt="Add Branch Filter" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Save the changes.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, create a new topic branch and switch to it. I am going to call it &lt;code&gt;features/complex-feature1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;​    &lt;code&gt;git checkout -b 'features/complex-feature1'&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Push the new branch to the remote server.&lt;/p&gt;

&lt;p&gt;​ &lt;code&gt;git push -u origin 'features/complex-feature1'&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Verify that the build definition got triggered against the new branch.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/40_BranchBuildTriggered.png" alt="Branch triggered on New Branch" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now let's make a change to the &lt;code&gt;.vsts-ci.yml&lt;/code&gt;. In order to keep things simple, I am just going to update the echo statement with the branch name.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/50_UpdatedEcho.png" alt="Branch triggered on New Branch" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Once again, let's commit and push the changes to the remote server.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Verify that a new build was triggered.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/60_UpdatedBuildTriggered.png" alt="Updated Build Trigger" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Confirm that the branch specific version of the build was executed.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/70_BranchBuild.png" alt="Branch triggered on New Branch" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This confirms that VSTS honors and executes the appropriate build definitions on the appropriate branch. Super cool!&lt;/p&gt;

&lt;h2&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;The ability to branch build definitions gives team members the ability to customize and test build changes in isolation. It also minimizes the disruption to on going development until the changes are ready to be merged and shared with the rest of the team.&lt;/p&gt;

&lt;h3&gt;Path Filters&lt;/h3&gt;

&lt;p&gt;It doesn't seem to be possible to setup path filters from the YAML file. That being said, it can still be setup by editing the build definition after the provisioning. &lt;/p&gt;

&lt;p&gt;This can be done by navigate to the &lt;code&gt;Triggers&lt;/code&gt; tab in the build definition and adding the path filter.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/80_PathFilter.png" alt="Path Filters" /&gt;&lt;/p&gt;

&lt;p&gt;In the above example, I want to make sure that the CI build does not trigger when I make changes to the support tools. &lt;/p&gt;

&lt;h3&gt;Scheduling Builds&lt;/h3&gt;

&lt;p&gt;Schedule builds also needs to be setup in a similar fashion to path filters. &lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/90_BuildSchedule.png" alt="Build Schedule" /&gt;&lt;/p&gt;

&lt;h3&gt;Multiple Build Definitions and Manual Setup&lt;/h3&gt;

&lt;p&gt;What happens when you have multiple &lt;code&gt;yml&lt;/code&gt; files within a single repository? I hadn't even considered this until I stumble across it in the documentation. &lt;/p&gt;

&lt;p&gt;Consider an example where the project already contains your wired up CI build but you'd like to use the second dedicated build for your production releases. &lt;/p&gt;

&lt;p&gt;This is certainly possible - if VSTS finds a a file named &lt;code&gt;.vsts-ci.yml&lt;/code&gt; in the root path then it attempts to wire it up as a CI &lt;a href="https://docs.microsoft.com/en-us/vsts/build-release/actions/build-yaml#automatically-create-a-yaml-build-definition"&gt;build automatically&lt;/a&gt;, but the additional builds needs to be &lt;a href="https://docs.microsoft.com/en-us/vsts/build-release/actions/build-yaml#manually-create-a-yaml-build-definition"&gt;setup manually&lt;/a&gt;. &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Start by creating a new build definition from within VSTS and choose &lt;code&gt;YAML&lt;/code&gt; as the template. Confirm the selection by clicking the &lt;code&gt;Apply&lt;/code&gt; button.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/100_NewBuildTemplate.png" alt="Build Schedule" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, click the ellipsis button &lt;code&gt;...&lt;/code&gt; and select the path to the YAML file and click &lt;code&gt;OK&lt;/code&gt; to confirm.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/110_ProdBuild.png" alt="Build Schedule" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Once saved, you can trigger the build as you would any other.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I can also confirm that VSTS treats YAML builds as regular builds and they can be used as the source for your release definitions.&lt;/p&gt;

&lt;h3&gt;Change Tracking&lt;/h3&gt;

&lt;p&gt;So the changes YAML file itself is tracked by &lt;code&gt;git&lt;/code&gt;, but does VSTS track the changes we do to the build definition after provisioning? Yes, it does. Under the covers, it looks like VSTS sets up an json-exportable definition of the build. This is not a replication of your &lt;code&gt;YAML&lt;/code&gt; build tasks, but rather maintains everything thats &lt;strong&gt;not&lt;/strong&gt; configurable in the &lt;code&gt;YAML&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;A history of all changes done to the definition can be viewed and compared from the history tab.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YamlBuildBranch/120_BuildHistory.png" alt="Build History" /&gt;&lt;/p&gt;

&lt;p&gt;I, for one, have become a fan of YAML builds and can't wait for this feature to come out of preview and become a permanent.&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/vsts/build-release/actions/ci-build-git"&gt;Define a CI build process for your Git repo | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/vsts/build-release/actions/build-yaml"&gt;CI Build in code using YAML | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-gb/vsts/build-release/concepts/definitions/build/variables?tabs=batch"&gt;Build variables | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/vsts/build-release/concepts/definitions/build/triggers"&gt;Build definition triggers | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/vsts/build-release/actions/build-yaml#automatically-create-a-yaml-build-definition"&gt;CI Build in code using YAML - Automatic Build Definition| Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/vsts/build-release/actions/build-yaml#manually-create-a-yaml-build-definition"&gt;CI Build in code using YAML - Manual Build Definition| Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>http://nullfactory.net/2018/01/build-pipeline-as-code-yaml-based-ci-build-for-dynamics-365-solutions/</id><title type="text">Build Pipeline as Code - YAML based CI Build for Dynamics 365 Solutions</title><summary type="html">&lt;p&gt;I first learned about YAML builds a while back when I was trying into integrate a project with AppVeyor. The concept of treating your build pipeline as first class code artefact was very appealing as it opens up so much possibilities. For me personally the highlights are: &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;History, versioning and branching of your build definitions&lt;/li&gt;
&lt;li&gt;Improve quality of build definitions and consistency across projects.&lt;/li&gt;
&lt;li&gt;Quickly reuse and repurpose builds onto different projects.&lt;/li&gt;
&lt;li&gt;Make maximum use of the underlying build platform.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These posts &lt;a href="https://blog.kloud.com.au/2017/11/26/vsts-build-definitions-as-yaml-part-1-what-and-why/"&gt;here&lt;/a&gt; and &lt;a href="https://www.marcusfelling.com/blog/2017/vsts-yaml-builds/"&gt;here&lt;/a&gt; dive deeper into the advantages and the different use cases.  &lt;/p&gt;

&lt;p&gt;A couple of months ago the Visual Studio Team Service (VSTS) team &lt;a href="https://blogs.msdn.microsoft.com/devops/2017/11/15/pipeline-as-code-yaml-preview/"&gt;announced&lt;/a&gt; support for the the same functionality in VSTS. Although the feature is still in preview, the VSTS team has continued to improve the feature and now provides the ability to export existing build definitions or individual tasks. In this post, I intend to take pre-existing build definition, converting it to a YAML build definition and make the necessary changes to get it to work as a CI build. &lt;/p&gt;

&lt;p&gt;In this post, I intend to port an existing definition to a YAML build definition and use it as a template to setup a new CI build for a second project. The source definition that I will be using is a basic version I use for Dynamics 365 projects. &lt;/p&gt;

</summary><published>2018-01-19T13:00:00Z</published><updated>2018-01-19T13:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2018/01/build-pipeline-as-code-yaml-based-ci-build-for-dynamics-365-solutions/" /><content type="html">&lt;p&gt;I first learned about YAML builds a while back when I was trying into integrate a project with AppVeyor. The concept of treating your build pipeline as first class code artefact was very appealing as it opens up so much possibilities. For me personally the highlights are: &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;History, versioning and branching of your build definitions&lt;/li&gt;
&lt;li&gt;Improve quality of build definitions and consistency across projects.&lt;/li&gt;
&lt;li&gt;Quickly reuse and repurpose builds onto different projects.&lt;/li&gt;
&lt;li&gt;Make maximum use of the underlying build platform.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These posts &lt;a href="https://blog.kloud.com.au/2017/11/26/vsts-build-definitions-as-yaml-part-1-what-and-why/"&gt;here&lt;/a&gt; and &lt;a href="https://www.marcusfelling.com/blog/2017/vsts-yaml-builds/"&gt;here&lt;/a&gt; dive deeper into the advantages and the different use cases.  &lt;/p&gt;

&lt;p&gt;A couple of months ago the Visual Studio Team Service (VSTS) team &lt;a href="https://blogs.msdn.microsoft.com/devops/2017/11/15/pipeline-as-code-yaml-preview/"&gt;announced&lt;/a&gt; support for the the same functionality in VSTS. Although the feature is still in preview, the VSTS team has continued to improve the feature and now provides the ability to export existing build definitions or individual tasks. In this post, I intend to take pre-existing build definition, converting it to a YAML build definition and make the necessary changes to get it to work as a CI build. &lt;/p&gt;

&lt;p&gt;In this post, I intend to port an existing definition to a YAML build definition and use it as a template to setup a new CI build for a second project. The source definition that I will be using is a basic version I use for Dynamics 365 projects. &lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;h2&gt;Prerequisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Visual Studio Team Services account with a &lt;code&gt;git&lt;/code&gt; repository. &lt;code&gt;tfsvc&lt;/code&gt; repositories are &lt;a href="https://docs.microsoft.com/en-us/vsts/build-release/actions/build-yaml"&gt;not supported&lt;/a&gt; at the time of writing this post.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Dynamics 365 solution prepared using the &lt;code&gt;generator-nullfactory-xrm&lt;/code&gt;  and then checked into the above &lt;code&gt;git&lt;/code&gt; repository.&lt;/p&gt;

&lt;p&gt;The following posts provide instructions in setting up the prerequisite project structure:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/10/release-strategy-for-dynamics-crm-prepping-part-1/"&gt;Release Strategy for Dynamics CRM - Part 1 - Preparation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2"&gt;Release Strategy for Dynamics CRM - Part 2 - Setting Up the Build&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An pre-setup build definition that successfully builds the code in the repository. &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;The Setup&lt;/h2&gt;

&lt;h3&gt;Enable Preview Features&lt;/h3&gt;

&lt;p&gt;As YAML build definitions are still in preview , users need to opt-in to the feature. Let's do this now:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Log-in to you VSTS instance with an Account Administrator. &amp;lt;&lt;reference back to the article showing the permission required&gt;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click on the Logged-in user profile picture. And click on the &lt;code&gt;Preview features&lt;/code&gt; in the resulting menu. This will will open up the &lt;code&gt;Preview features&lt;/code&gt; drawer.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YAMLBuild/10_EnablePreview.png" alt="Enable Preview" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In the first drop down make sure that the &lt;code&gt;for this account [your-account-name]&lt;/code&gt; is selected.  Next, turn on the &lt;code&gt;Build YAML definitions&lt;/code&gt; feature. &amp;lt;&amp;lt;&gt;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YAMLBuild/20_EnablePreviewDrawer.png" alt="Enable Preview Drawer" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Export the Build Definition&lt;/h3&gt;

&lt;p&gt;Now let's navigate to our build definition that we're going to be using as the source template.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Navigate to your build using the menu &lt;code&gt;Build and Release &amp;gt; Build&lt;/code&gt; and selecting the &lt;code&gt;Definitions&lt;/code&gt; tab.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click the ellipsis on the build definition and select &lt;code&gt;Edit...&lt;/code&gt; from the context menu.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YAMLBuild/30_EditBuildDef.png" alt="Edit Build Definition" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YAMLBuild/40_ExistingBuild.png" alt="Existing Build Definition" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note that this build definition uses a &lt;code&gt;MSBuild&lt;/code&gt; task instead of a &lt;code&gt;Visual Studio Build&lt;/code&gt; as such does not require the &lt;code&gt;visualstudio&lt;/code&gt; demand.&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If not already selected, click on the &lt;code&gt;Process- Build process&lt;/code&gt; option.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YAMLBuild/44_ExistingBuildProcessStep.png" alt="View YAML Build" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Note the &lt;code&gt;View YAML&lt;/code&gt; link to the far right of the editor. Click on it to open a popup showing a generated YAML definition.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YAMLBuild/50_ViewYAML.png" alt="View YAML Build" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YAMLBuild/60_BuildExport.png" alt="Export Build" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For reference, I've uploaded the generated file &lt;a href="http://nullfactory.net/images/posts/YAMLBuild/vsts_generated.yml"&gt;here&lt;/a&gt;. &lt;/p&gt;

&lt;h3&gt;Clean Up&lt;/h3&gt;

&lt;p&gt;The next step is to clean up and fix the exported script. The generation process identified some warnings and errors for us, so let's start with those. In this particular instance they were all related to variables not being defined:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- snip --&amp;gt;

#Your build definition references an undefined variable named ‘Parameters.solution’. Create or edit the build definition for this YAML file, define the variable on the Variables tab. See https://go.microsoft.com/fwlink/?linkid=865972
#Your build definition references the ‘BuildPlatform’ variable, which you’ve selected to be settable at queue time. Create or edit the build definition for this YAML file, define the variable on the Variables tab, and then select the option to make it settable at queue time. See https://go.microsoft.com/fwlink/?linkid=865971

&amp;lt;!-- snip --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following variables were found to be undefined:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Parameters.solution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build.sourcesdirectory&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build.artifactstagingdirectory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And the following were identified as being set when the build is queued:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BuildPlatform&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BuildConfiguration&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The errors related to the variables prefixed with &lt;code&gt;build.&lt;/code&gt; are not a problem and can be safely ignored. They are predefined variables and are indeed &lt;a href="https://docs.microsoft.com/en-us/vsts/build-release/concepts/definitions/build/variables?tabs=batch"&gt;available in the build environment&lt;/a&gt;.  &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Create a new PowerShell task that defines the variables and move it to the first in the order. Next set the &lt;code&gt;BuildConfiguration&lt;/code&gt; and &lt;code&gt;BuildPlatform&lt;/code&gt; was to &lt;code&gt;release&lt;/code&gt; and &lt;code&gt;any cpu&lt;/code&gt; respectively. And finally &lt;code&gt;Parameters.Solution&lt;/code&gt; to the actual solution being built - as this example contains only one solution file, set it to &lt;code&gt;**/*.sln&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;steps:
- powershell: |
    Write-Host '##vso[task.setvariable variable=BuildConfiguration;]release'
    Write-Host '##vso[task.setvariable variable=BuildPlatform;]any cpu'
    Write-Host '##vso[task.setvariable variable=Parameters.solution;]**/*.sln'
  displayName: Create variables
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, escape any slashes in task attribute values. I had to update &lt;code&gt;VSTest@2&lt;/code&gt; and &lt;code&gt;CopyFiles@2&lt;/code&gt; tasks.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- task: VSTest@2
  inputs:
    testAssemblyVer2: "**\\$(BuildConfiguration)\\*test*.dll
!**\\obj\\**"
    platform: "$(BuildPlatform)"
    configuration: "$(BuildConfiguration)"


- task: CopyFiles@2
  inputs:
    SourceFolder: "$(build.sourcesdirectory)"
    Contents: "**\\bin\\$(BuildConfiguration)\\**"
    TargetFolder: "$(build.artifactstagingdirectory)"
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add a &lt;code&gt;displayName&lt;/code&gt; node for each of the tasks - this does not have an impact on the operation of the build itself, but makes it easier to keep track of the tasks being executed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- snip --&amp;gt;
- task: NuGetCommand@2
  displayName: NuGet restore **\*.sln
&amp;lt;!-- snip --&amp;gt;
- task: MSBuild@1
  displayName: Build solution **/*.sln
&amp;lt;!-- snip --&amp;gt;
- task: CopyFiles@2
  displayName: "Copy Files to: $(build.artifactstagingdirectory)"
&amp;lt;!-- snip --&amp;gt;
- task: CopyFiles@2
  displayName: "Copy Deployment Scripts to: $(build.artifactstagingdirectory)"
&amp;lt;!-- snip --&amp;gt;
- task: DeleteFiles@1
  displayName: "Delete custom assemblies from $(build.artifactstagingdirectory)"
&amp;lt;!-- snip --&amp;gt;
- task: PublishBuildArtifacts@1
  displayName: "Publish Artifact: drop"
&amp;lt;!-- snip --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And we're done. Download the final form of the file &lt;a href="http://nullfactory.net/images/posts/YAMLBuild/updated_definition.yml"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Deployment&lt;/h3&gt;

&lt;p&gt;The deployment process itself is very simple, all we need to do is create a &lt;code&gt;.vsts-ci.yml&lt;/code&gt; and drop it in the root of your repository and VSTS would automatically generate the CI build.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Save the cleaned up build definition with the name of &lt;code&gt;.vsts-ci.yml&lt;/code&gt; and drop it in the root folder of your second project repository.&lt;/li&gt;
&lt;li&gt;Commit your changes and push them to remote.&lt;/li&gt;
&lt;li&gt;Within VSTS, navigate to the &lt;code&gt;Build and Release&lt;/code&gt; and ensure that there is a new folder with the repository's name.&lt;/li&gt;
&lt;li&gt;Navigate into this folder and verify that a new build has been created &lt;code&gt;your_repo_name CI&lt;/code&gt;and that it is currently in progress.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And that's it, you've got a working CI build.&lt;/p&gt;

&lt;h2&gt;Final Thoughts&lt;/h2&gt;

&lt;h3&gt;Reusing Definition for Dynamics 365&lt;/h3&gt;

&lt;p&gt;Thanks to the use of the yeoman generator, my Dynamics 365 projects use an identical project structure. This mean that I can just copy the &lt;code&gt;.vsts-ci.yml&lt;/code&gt; to the root of repository of the new project, make any project specific changes if necessary and you've got a working CI build.&lt;/p&gt;

&lt;h3&gt;Branching Behaviour&lt;/h3&gt;

&lt;p&gt;I was curious to find out what happens when we branch the YAML build. Does VSTS create a new instance of the definition for each of the branches? Look out for it's blog post.&lt;/p&gt;

&lt;h3&gt;Defining Variables via the UI&lt;/h3&gt;

&lt;p&gt;As an alternative to defining the variables using a PowerShell or Shell a task, they can also be defined using the VSTS user interface.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Skip the previous step where we initialize the variables using the PowerShell task. Continue on with the other steps.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Check-in and push the CI build to remote.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Navigate to the &lt;code&gt;Build and Release&lt;/code&gt; menu and &lt;code&gt;Build&lt;/code&gt; tab and verify that a new build was provisioned as expected.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The initial check-in of the CI build itself is going to fail as it will be triggered the moment the build definition is provisioned.&lt;/em&gt; &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, &lt;code&gt;Edit&lt;/code&gt; the definition and navigate to the &lt;code&gt;Variables&lt;/code&gt; tab.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Define the &lt;code&gt;BuildConfiguration&lt;/code&gt;, &lt;code&gt;BuildPlatform&lt;/code&gt;, &lt;code&gt;Parameters.solution&lt;/code&gt; variables:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YAMLBuild/70_AltSetVariables.png" alt="Set Process Variables" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Test out your new definition by making a change to the repository or explicitly triggering a new build.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The downside of this method is that all the components required by the build definition is not contained within the YAML file. &lt;/p&gt;

&lt;p&gt;So why would I want to take this approach?  Secrets. This is the perfect way to store your secrets and avoid inadvertently checking them into your repository.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/YAMLBuild/80_SecretVariable.png" alt="Secret Process Variables" /&gt;&lt;/p&gt;

&lt;p&gt;Therefore I would recommend using an hybrid approach. Should your CI build require the use of sensitive information, define them via the UI and place the rest of the variables in the script itself.&lt;/p&gt;

&lt;h3&gt;Alternative Approaches&lt;/h3&gt;

&lt;p&gt;I've noticed that different vendors and tend to have their own flavour of what a YAML build file format would look like. Unfortunately, this means that if a development team was to ever to switch build providers or fork a copy of the project to another build platform, they would likely need to rework or add platform specific build scripts.&lt;/p&gt;

&lt;p&gt;One approach I have seen, especially in OSS projects, is to use a platform agnostic script (PowerShell / Shell) that can be used to build your application in isolation and setup the CI build task to make a call to this script. You still get a lot of the advantages mentioned previously, but forego the tight integration and features of a particular build systems.&lt;/p&gt;

&lt;h3&gt;Next Steps&lt;/h3&gt;

&lt;p&gt;Since most of the teams I work with use VSTS exclusively, I was super stoked when this announcement was made. This feature is a perfect candidate to be included as part of the &lt;code&gt;generator-nullfactory-xrm&lt;/code&gt; yeoman  generator as it removes the manual steps and further reduces the time it takes to setup a CI pipeline within VSTS.&lt;/p&gt;

&lt;p&gt;The next release of the generator will include the ability to generate a tailored CI build for VSTS with the I hopes of adding other providers in the future. It's will be implemented as a sub-generator and would needed be opted into. &lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.kloud.com.au/2017/11/26/vsts-build-definitions-as-yaml-part-1-what-and-why/"&gt;VSTS Build Definitions as YAML Part 1: What and Why? | Kloud Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.marcusfelling.com/blog/2017/vsts-yaml-builds/"&gt;VSTS YAML Builds (Pipeline as code) - Marcus Felling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blogs.msdn.microsoft.com/devops/2017/11/15/pipeline-as-code-yaml-preview/"&gt;Pipeline as code (YAML) preview – Microsoft DevOps Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.kloud.com.au/2017/11/26/vsts-build-definitions-as-yaml-part-2-how/"&gt;VSTS Build Definitions as YAML Part 2: How? | Kloud Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.visualstudio.com/en-us/docs/build/concepts/process/phases"&gt;Build and Release Automation Phases in VSTS and TFS | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/vsts/build-release/actions/build-yaml"&gt;CI Build in code using YAML | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/vsts/build-release/concepts/definitions/_shared/set-variables-in-scripts?tabs=powershell"&gt;Define and modify your variables in a script | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Microsoft/vsts-agent/blob/master/docs/preview/yamlgettingstarted-powershell.md"&gt;vsts-agent/yamlgettingstarted-powershell.md at master · Microsoft/vsts-agent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://chamindac.blogspot.com.au/2017/11/build-definition-as-code-with-yaml.html"&gt;Chaminda's Blog: Build Definition as Code with YAML Builds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Microsoft/vsts-agent/blob/master/.vsts.ci.yml"&gt;vsts-agent/.vsts.ci.yml at master · Microsoft/vsts-agent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/vsts/build-release/concepts/definitions/build/variables?tabs=batch"&gt;Build variables | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.motowilliams.com/vsts-yaml-build-definitions"&gt;Eric Williams - VSTS: YAML Build Definitions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://mattvsts.blogspot.com.au/2017/11/yaml-build-definitions-in-team-build.html"&gt;Matt's ALM space: YAML Build Definitions in the Team Build, now what?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>http://nullfactory.net/2017/10/crm-saturday-melbourne-2017-presentation-slide-deck/</id><title type="text">CRM Saturday Melbourne 2017 - Presentation Slide Deck</title><summary type="html">&lt;p&gt;&lt;a href="https://www.slideshare.net/shanec_/zero-to-devops-source-control-release-strategy-crm-saturday-2017"&gt;&lt;img src="http://nullfactory.net/images/posts/CrmSatSlideDeck/crm-sat-slide-deck.png" alt="CRM Saturday Melbourne 2017" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I know its a "little" late, but here's the slide deck from my CRM Saturday 2017 presentation  - &lt;code&gt;Zero to DevOps - Source Control and Release Strategy for Dynamics 365 Solutions&lt;/code&gt;. &lt;/p&gt;

</summary><published>2017-10-08T13:00:00Z</published><updated>2017-10-08T13:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/10/crm-saturday-melbourne-2017-presentation-slide-deck/" /><content type="html">&lt;p&gt;&lt;a href="https://www.slideshare.net/shanec_/zero-to-devops-source-control-release-strategy-crm-saturday-2017"&gt;&lt;img src="http://nullfactory.net/images/posts/CrmSatSlideDeck/crm-sat-slide-deck.png" alt="CRM Saturday Melbourne 2017" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I know its a "little" late, but here's the slide deck from my CRM Saturday 2017 presentation  - &lt;code&gt;Zero to DevOps - Source Control and Release Strategy for Dynamics 365 Solutions&lt;/code&gt;. &lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;&lt;a href="https://www.slideshare.net/shanec_/zero-to-devops-source-control-release-strategy-crm-saturday-2017"&gt;https://www.slideshare.net/shanec_/zero-to-devops-source-control-release-strategy-crm-saturday-2017&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As always, feel free to reach me through social media if you have any questions.&lt;/p&gt;
</content></entry><entry><id>http://nullfactory.net/2017/10/dont-forget-to-install-the-just-in-time-debugger/</id><title type="text">Don't Forget to Install the Just-In-Time Debugger</title><summary type="html">&lt;p&gt;Today I learned that you can have an installation of Visual Studio 2017 without the JIT debugger - Yup, you really can.  This meant that I could not use the technique of attaching a debugger at runtime using the  &lt;code&gt;System.Diagnostics.Debugger.Launch();&lt;/code&gt; code snippet. &lt;/p&gt;

&lt;p&gt;When the application executes the launch code, nothing happens - no error nor exception. The method even returns &lt;code&gt;true&lt;/code&gt; indicating a a successful launch.&lt;/p&gt;

</summary><published>2017-10-07T13:00:00Z</published><updated>2017-10-07T13:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/10/dont-forget-to-install-the-just-in-time-debugger/" /><content type="html">&lt;p&gt;Today I learned that you can have an installation of Visual Studio 2017 without the JIT debugger - Yup, you really can.  This meant that I could not use the technique of attaching a debugger at runtime using the  &lt;code&gt;System.Diagnostics.Debugger.Launch();&lt;/code&gt; code snippet. &lt;/p&gt;

&lt;p&gt;When the application executes the launch code, nothing happens - no error nor exception. The method even returns &lt;code&gt;true&lt;/code&gt; indicating a a successful launch.&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;After equal parts of scouring the web and pulling my hair out, I eventually stumbled upon the following option in the Visual Studio setup:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/JITDebugger/10_installdebugger.png" alt="Install Debugger" /&gt;&lt;/p&gt;

&lt;p&gt;The combination of features selected had somehow unchecked the Just-In-Time debugger. Heck, I didn't even know you could &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; install it. I hope this helps someone else out there.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/JITDebugger/20_choosejitdebugger.png" alt="Choose Debugger" /&gt;&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://msdn.microsoft.com/en-us/library/system.diagnostics.debugger.launch(v=vs.110).aspx"&gt;Debugger.Launch Method (System.Diagnostics)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://defragdev.com/blog/?p=668"&gt;The wonders of Debugger.Launch() | Mark's Devblog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blogs.msdn.microsoft.com/mapo/2013/11/07/debugger-launch-not-displaying-jit-debugger-selection-popup-on-windows-88-1/"&gt;Debugger.Launch() not displaying JIT debugger selection popup on Windows 8/8.1 – Scattered Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/12655965/debugger-launch-not-working"&gt;c# - Debugger.Launch not working - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://social.msdn.microsoft.com/Forums/vstudio/en-US/9a539c40-1869-44b8-9aed-9f9d7d402d7c/mysterious-vs-jit-debugger-invocation-failure?forum=vsdebug"&gt;Mysterious VS JIT debugger invocation failure&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>http://nullfactory.net/2017/10/tail-using-powershell/</id><title type="text">Tail using PowerShell</title><summary type="html">&lt;p&gt;Consider a scenario where you are diagnosing an issue on a production server. You've enabled the logs and got everything setup to reproduce the issue. Queue the trigger to invoke the misbehaving operation and finally wait for the log file to update.&lt;/p&gt;

&lt;p&gt;Staring at the log file size to change is no fun nor is refreshing the file periodically. I want to be notified the moment the log gets updated in real-time. This is exactly what a program like &lt;a href="https://en.wikipedia.org/wiki/Tail_(Unix)"&gt;&lt;code&gt;tail&lt;/code&gt;&lt;/a&gt; does - it monitors the file for changes and outputs the &lt;em&gt;tail&lt;/em&gt; end of the file.&lt;/p&gt;

&lt;p&gt;There are a few incarnations of tail out there that do the job perfectly fine, but given that this was a production environment I was not keep about installing new tools.&lt;/p&gt;

&lt;p&gt;Luckily, the &lt;code&gt;Get-Content&lt;/code&gt; PowerShell cmdlet has this functionality built-in. This is the combo that I finally settled on:&lt;/p&gt;

</summary><published>2017-10-06T13:00:00Z</published><updated>2017-10-06T13:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/10/tail-using-powershell/" /><content type="html">&lt;p&gt;Consider a scenario where you are diagnosing an issue on a production server. You've enabled the logs and got everything setup to reproduce the issue. Queue the trigger to invoke the misbehaving operation and finally wait for the log file to update.&lt;/p&gt;

&lt;p&gt;Staring at the log file size to change is no fun nor is refreshing the file periodically. I want to be notified the moment the log gets updated in real-time. This is exactly what a program like &lt;a href="https://en.wikipedia.org/wiki/Tail_(Unix)"&gt;&lt;code&gt;tail&lt;/code&gt;&lt;/a&gt; does - it monitors the file for changes and outputs the &lt;em&gt;tail&lt;/em&gt; end of the file.&lt;/p&gt;

&lt;p&gt;There are a few incarnations of tail out there that do the job perfectly fine, but given that this was a production environment I was not keep about installing new tools.&lt;/p&gt;

&lt;p&gt;Luckily, the &lt;code&gt;Get-Content&lt;/code&gt; PowerShell cmdlet has this functionality built-in. This is the combo that I finally settled on:&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;&lt;code&gt;Get-Content log.txt -tail 5 -wait&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;-tail&lt;/code&gt; argument takes in the number of lines to show from the end of the file and &lt;code&gt;-wait&lt;/code&gt; specifies that  it should continue to monitor the file.&lt;/p&gt;

&lt;p&gt;Granted that this method does not have highlighting capabilities that a dedicated tool would have, but its a pretty useful option to have in a pinch.&lt;/p&gt;

&lt;p&gt;Finally, save a few key strokes by using the alias:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cat log.txt -tail 5 -wait&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/187587/looking-for-a-windows-equivalent-of-the-unix-tail-command"&gt;Looking for a windows equivalent of the unix tail command - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackify.com/13-ways-to-tail-a-log-file-on-windows-unix/"&gt;13 Ways to Tail a Log File on Windows &amp;amp; Linux: Top Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/powershell/module/Microsoft.PowerShell.Management/Get-Content?view=powershell-5.1"&gt;Microsoft Docs - Get-Content&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>http://nullfactory.net/2017/10/mocking-and-testing-a-webservice-using-soapui/</id><title type="text">Mocking and Testing a WebService using SoapUI</title><summary type="html">&lt;p&gt;I have recently been working on an implementation of a WCF client interacts with a remote SOAP web service. Unfortunately this service did not have a development version that I could interactively test my requests against.&lt;/p&gt;

&lt;p&gt;Armed with just the WSDL and the schema for expected responses, I needed to find a way to mock the remote service in order to confirm the functionality of the client. This is where SOAP UI comes in - SOAP UI is tool that allows me to point it to service contract (WSDL or REST) and mock the responses that each of the actions would generate. And finally provides the functionality to host and serve these mocked responses so that they can be consumed by different clients.&lt;/p&gt;

&lt;p&gt;I will be using the freely available &lt;a href="http://www.webservicex.net/globalweather.asmx"&gt;http://www.webservicex.net/globalweather.asmx&lt;/a&gt; web service to demonstrate the process.&lt;/p&gt;

</summary><published>2017-10-05T13:00:00Z</published><updated>2017-10-05T13:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/10/mocking-and-testing-a-webservice-using-soapui/" /><content type="html">&lt;p&gt;I have recently been working on an implementation of a WCF client interacts with a remote SOAP web service. Unfortunately this service did not have a development version that I could interactively test my requests against.&lt;/p&gt;

&lt;p&gt;Armed with just the WSDL and the schema for expected responses, I needed to find a way to mock the remote service in order to confirm the functionality of the client. This is where SOAP UI comes in - SOAP UI is tool that allows me to point it to service contract (WSDL or REST) and mock the responses that each of the actions would generate. And finally provides the functionality to host and serve these mocked responses so that they can be consumed by different clients.&lt;/p&gt;

&lt;p&gt;I will be using the freely available &lt;a href="http://www.webservicex.net/globalweather.asmx"&gt;http://www.webservicex.net/globalweather.asmx&lt;/a&gt; web service to demonstrate the process.&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;Let's start off with a single request:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Open up the SOAP UI application and add connection to the SOAP service. Do this by navigating to the &lt;code&gt;File &amp;gt; New SOAP Project&lt;/code&gt; menu option.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Provide a name for the project and set the url to the WSDL file to &lt;a href="http://www.webservicex.net/globalweather.asmx?wsdl"&gt;http://www.webservicex.net/globalweather.asmx?wsdl&lt;/a&gt; . Keep the &lt;code&gt;Create Requests&lt;/code&gt; check box checked: &lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/10_AddNewSoapProject.png" alt="Add new SOAP project" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now let's create a mock version of our web service. Right click on the &lt;code&gt;GetCitiesByCountry&lt;/code&gt; method and select &lt;code&gt;Add to MockService&lt;/code&gt; option in the context menu.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/20_AddToMockService.png" alt="Add to mock service" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Provide it with a name, and select &lt;code&gt;Yes&lt;/code&gt; to open it within the editor.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/30_EnterNameForService.png" alt="Enter name for service" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/40_OpenMockServiceEditor.png" alt="Open mock service editor" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In the resulting dialog, paste the response you would like to receive when a request is made.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/50_MockedResponse.png" alt="Mocked response" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now that we have the response setup, let's start up the mock service to serve up our requests. Do this by double clicking the &lt;code&gt;WeatherMockService&lt;/code&gt; node to bring up the service status dialog and clicking on the &lt;code&gt;Start&lt;/code&gt; (play icon) button.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/70_MockingServiceStarted.png" alt="Mocking service started" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now let's see if our response works. The easiest way to do this is to right-click on the response that we previously populated, and on the context-menu select the &lt;code&gt;Open Request&lt;/code&gt; option.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/75_MockServiceTest.png" alt="Mocking service test" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Either select the pre-generated request, or select the option to create a new one. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Modify the resulting request as necessary. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Once ready, click the submit (play icon) button to send the request.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/78_MockServiceTestResult.png" alt="Mocking service test result" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Confirm that you have received the previously setup request.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now we have very basic mock and responses working, let's make it a little bit more complex. In my live system, any time the service method is called it would reply with a different response subject to some external variables. I wanted to mock the same functionality so that I can better test how my client code reacts to the different sequences. &lt;/p&gt;

&lt;p&gt;I did a bit of research and found another individual who had the same requirement: &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/32975240/soapui-mock-service-custom-sequence-of-responses"&gt;https://stackoverflow.com/questions/32975240/soapui-mock-service-custom-sequence-of-responses&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This approach allows us to orchestrate the responses that are returned. In this particular example there are no smarts built in apart from the service responding to the requests in sequence.&lt;/p&gt;

&lt;p&gt;Let's setup our sequence of responses:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Create a second response for the request. &lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/80_MockSecondResponse.png" alt="Mock second response" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Provide it with a new response body as done previously.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/90_MockSecondResponseBody.png" alt="Mock second response body" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, right-click on the &lt;code&gt;GetCitiesByCountry&lt;/code&gt; method in the mock service and select &lt;code&gt;Show MockOperation Editor&lt;/code&gt; in the resulting dialog.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/100_MockOperationEditor.png" alt="Mock operation editor" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In the resulting dialog,  choose the &lt;code&gt;SEQUENCE&lt;/code&gt; as the &lt;code&gt;Dispatch&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/110_ScriptEditor.png" alt="Sciprt editor" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Paste the following script in the script section. This script controls the order in which the responses are returned. Update the &lt;code&gt;myRespList&lt;/code&gt; array to change this sequence.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// get the list from the context
def myRespList = context.myRespList


// if list is null or empty reinitalize it
if(!myRespList || !myRespList?.size){   
    // list in the desired output order using the response names that your
    // create in your mockservice
    myRespList = ["Response 2","Response 1"]  
}
// take the first element from the list
def resp = myRespList.take(1)[0]


// update the context with the list without this element
context.myRespList = myRespList.drop(1)


// return the response
log.info "--&amp;gt;"+resp
return resp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/120_FinalScript.png" alt="Final script" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Test out the response by clicking on the test script (play button) just above the editor. SOAP UI responds with showing us the first request that would be sent.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/140_ScriptTestRun2.png" alt="Script returned response 2" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Testing the script again, and receive the second response. Good, the script seems to be doing its job.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/130_ScriptTestRun1.png" alt="Script returned response 1" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Let's do one final test with an actual request to make sure its working as expected. &lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/160_RequestSecondRun.png" alt="Request first run" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;And run the request again to receive the second response.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/MockSoapUI/150_RequestFirstRun.png" alt="Request second run" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I love the fact that this tool provides the right combination of ease of use and functionality. And allows a new developer to quickly setup the basics and then extend the test scenarios as they become more complex.&lt;/p&gt;

&lt;p&gt;This is going into my developer tool belt for sure.&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.soapui.org/getting-started/your-first-soapui-project.html"&gt;Your First SoapUI Project | Getting started with SoapUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.soapui.org/getting-started/10-tips-for-the-soapui-beginner.html"&gt;10 Tips for the SoapUI Beginner | Getting started with SoapUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/32975240/soapui-mock-service-custom-sequence-of-responses"&gt;groovy - SoapUI Mock Service Custom Sequence of Responses - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>http://nullfactory.net/2017/06/continuous-integration-and-continuous-delivery-of-dynamics-365-solutions-using-vsts/</id><title type="text">Continuous Integration and Continuous Delivery of Dynamics 365 Solutions using VSTS</title><summary type="html">&lt;p&gt;In previous posts I've setup build and release defintions for Dynamics CRM solutions and in this one I try my attempt at setting up an automated Continuous Delivery pipeline. There are two popular strategies used to make sure that &lt;a href="https://puppet.com/blog/continuous-delivery-vs-continuous-deployment-what-s-diff"&gt;every change made to a system can be deployed&lt;/a&gt; successfully to secondary environment:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Continuous Integration (CI)&lt;/p&gt;

&lt;p&gt;A CI build is one that is usually kicked off any time a piece of code is checked-in in order to give early visibility of any potential failures. The success of a build is dependent on the actual build plus any unit tests.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scheduled&lt;/p&gt;

&lt;p&gt;A scheduled build, also commonly referred to as a &lt;code&gt;Nightly Build&lt;/code&gt;, is a build and release that is performed on a regular cadence - usually every night. Once again, on the successful completion of the build and automated unit test, a new release is pushed to the staging environment.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Both methods appear to be doing the same thing, so when should I choose a CI build + release over a scheduled build? The most &lt;a href="https://stackoverflow.com/questions/417134/continuous-integration-vs-nightly-builds"&gt;common metric&lt;/a&gt; appears to be the duration of your build and unit tests. The size of the team, the project and code complexity and the frequency of check-ins can have an impact on the time it takes for build and long running unit tests to execute. In these scenarios a &lt;code&gt;Scheduled&lt;/code&gt; build makes more sense.&lt;/p&gt;

&lt;h2&gt;Overview&lt;/h2&gt;

&lt;p&gt;I was disappointed to find out that, at the time of writing this post, VSTS release definitions does not provide an option to trigger off a successful a scheduled build. The only options available are to trigger it off of a CI build or the automated schedule on the release itself. &lt;/p&gt;

&lt;p&gt;Luckily, Rene van Osnabrugge's &lt;a href="https://roadtoalm.com/2017/03/30/trigger-release-pipeline-only-for-scheduled-builds/"&gt;excellent post&lt;/a&gt; provides us with a workaround for this restriction. Here's an overview how it works:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Setup a single build that performs all three roles (manually invoked, CI and scheduled). &lt;/li&gt;
&lt;li&gt;Add a task into the build that would to figure out which method was used to invoke. &lt;/li&gt;
&lt;li&gt;Apply the the reason as a build tag onto itself. &lt;/li&gt;
&lt;li&gt;Update the release definition to filter the the release trigger to be filtered only the scheduled tags.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets get started setting it up.&lt;/p&gt;

</summary><published>2017-06-24T14:00:00Z</published><updated>2017-06-24T14:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/06/continuous-integration-and-continuous-delivery-of-dynamics-365-solutions-using-vsts/" /><content type="html">&lt;p&gt;In previous posts I've setup build and release defintions for Dynamics CRM solutions and in this one I try my attempt at setting up an automated Continuous Delivery pipeline. There are two popular strategies used to make sure that &lt;a href="https://puppet.com/blog/continuous-delivery-vs-continuous-deployment-what-s-diff"&gt;every change made to a system can be deployed&lt;/a&gt; successfully to secondary environment:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Continuous Integration (CI)&lt;/p&gt;

&lt;p&gt;A CI build is one that is usually kicked off any time a piece of code is checked-in in order to give early visibility of any potential failures. The success of a build is dependent on the actual build plus any unit tests.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scheduled&lt;/p&gt;

&lt;p&gt;A scheduled build, also commonly referred to as a &lt;code&gt;Nightly Build&lt;/code&gt;, is a build and release that is performed on a regular cadence - usually every night. Once again, on the successful completion of the build and automated unit test, a new release is pushed to the staging environment.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Both methods appear to be doing the same thing, so when should I choose a CI build + release over a scheduled build? The most &lt;a href="https://stackoverflow.com/questions/417134/continuous-integration-vs-nightly-builds"&gt;common metric&lt;/a&gt; appears to be the duration of your build and unit tests. The size of the team, the project and code complexity and the frequency of check-ins can have an impact on the time it takes for build and long running unit tests to execute. In these scenarios a &lt;code&gt;Scheduled&lt;/code&gt; build makes more sense.&lt;/p&gt;

&lt;h2&gt;Overview&lt;/h2&gt;

&lt;p&gt;I was disappointed to find out that, at the time of writing this post, VSTS release definitions does not provide an option to trigger off a successful a scheduled build. The only options available are to trigger it off of a CI build or the automated schedule on the release itself. &lt;/p&gt;

&lt;p&gt;Luckily, Rene van Osnabrugge's &lt;a href="https://roadtoalm.com/2017/03/30/trigger-release-pipeline-only-for-scheduled-builds/"&gt;excellent post&lt;/a&gt; provides us with a workaround for this restriction. Here's an overview how it works:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Setup a single build that performs all three roles (manually invoked, CI and scheduled). &lt;/li&gt;
&lt;li&gt;Add a task into the build that would to figure out which method was used to invoke. &lt;/li&gt;
&lt;li&gt;Apply the the reason as a build tag onto itself. &lt;/li&gt;
&lt;li&gt;Update the release definition to filter the the release trigger to be filtered only the scheduled tags.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets get started setting it up.&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;h2&gt;Prerequisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Visual Studio Team Services&lt;/li&gt;
&lt;li&gt;Existing team build - I will be re-using a Dynamics CRM project that I have used in &lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2/"&gt;my previous post&lt;/a&gt;. &lt;/li&gt;
&lt;li&gt;Existing release definition - Once again, I am using one that I've setup &lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-release-part-3/"&gt;previously&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;The Build Definition&lt;/h2&gt;

&lt;p&gt;As in my previous posts I will be using a standard Dynamics CRM build for this demonstration. Follow the instructions in &lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-build-part-2/"&gt;my previous post&lt;/a&gt; for setting this up .&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmCICD/10_BuildDefinition.png" alt="Build Definition" /&gt;&lt;/p&gt;

&lt;p&gt;Now let's make the following modifications:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;From within the build definition, navigate to the &lt;code&gt;Triggers&lt;/code&gt; tab.&lt;/li&gt;
&lt;li&gt;Enable the Continuous Integration trigger.&lt;/li&gt;
&lt;li&gt;Check the &lt;code&gt;Batch changes while a build is in progress&lt;/code&gt; check box. &lt;/li&gt;
&lt;li&gt;Add a new Path filter by clicking the &lt;code&gt;add&lt;/code&gt; button.&lt;/li&gt;
&lt;li&gt;Set the type to &lt;code&gt;Exclude&lt;/code&gt; and &lt;code&gt;Path specification&lt;/code&gt; to &lt;code&gt;/Nullfactory.Xrm.Tooling&lt;/code&gt;. We don't really care for our tools to  This is so that we only trigger on the actual solution and not the supporting tools/project.&lt;/li&gt;
&lt;li&gt;Now enable the scheduled trigger.&lt;/li&gt;
&lt;li&gt;Provide a schedule that works for your team.&lt;/li&gt;
&lt;li&gt;Finally, save the changes.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmCICD/20_BuildDefinitionTrigger.png" alt="Build Definition Trigger" /&gt;&lt;/p&gt;

&lt;h3&gt;Tagging The Build&lt;/h3&gt;

&lt;p&gt;Next, we update the build to tag itself upon a successful build.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;I downloaded the &lt;a href="https://gist.githubusercontent.com/renevanosnabrugge/3fa094790fab2b06db970d0da81a71b0/raw/a99220346be3803297412a4b580d8e1bd6dcbcf0/Set-BuildTagToTrigger.ps1"&gt;Set-BuildTagToTrigger.ps1&lt;/a&gt; script and added it part of the &lt;code&gt;Nullfactory.Xrm.Tooling/Scripts&lt;/code&gt; project folder.&lt;/li&gt;
&lt;li&gt;Commit and push the changes to the remote repository.&lt;/li&gt;
&lt;li&gt;From within the build editor, click on the &lt;code&gt;Add Task&lt;/code&gt; button and select a PowerShell task. I placed it as the last step in the order.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Configure it with the following values:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Display Name :&lt;code&gt;Tag Build Reason&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Type : &lt;code&gt;File Path&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Script Path : &lt;code&gt;Nullfactory.Xrm.Tooling/Scripts/Set-BuildTagToTrigger.ps1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Arguments : &lt;code&gt;-BuildId $(Build.BuildId)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmCICD/30_SetTagReasonPowerShell.png" alt="Set Tag Reason PowerShell" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ensure that the task only runs if all previous tasks have succeeded. Do this by navigating into &lt;code&gt;Control Options&lt;/code&gt; section and selecting the option within the &lt;code&gt;Run this task&lt;/code&gt; drop down.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In order for the the script to have authenticated access to the REST service it requires access to the OAuth token. Do this now navigating to the &lt;code&gt;Options&lt;/code&gt; tab and enabling the &lt;code&gt;Allow scripts to access OAuth token&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmCICD/40_AllowODataToken.png" alt="OData Token" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Queue a new build and verify that a tag was associated with the build. Note that since we invoked the build explicitly, a &lt;code&gt;manual&lt;/code&gt; tag was added.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmCICD/50_VerifyBuild.png" alt="Verify Build" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The tags applied to the new build are the same values as the build reason environmental variable. We only care about the following scenarios:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Manual&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IndividualCI&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BatchedCI&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Schedule&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In fact, we only care about the &lt;code&gt;Schedule&lt;/code&gt; typed of builds. Find the full list of available values &lt;a href="https://www.visualstudio.com/en-us/docs/build/define/variables"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;The Release Definition&lt;/h2&gt;

&lt;p&gt;Now that the build is complete and we've proven that the solution is good enough to be deployed, let's create and augment our release definition.&lt;/p&gt;

&lt;p&gt;Follow the steps &lt;a href="http://nullfactory.net/2016/11/release-strategy-for-dynamics-crm-setting-up-the-release-part-3/"&gt;described here&lt;/a&gt; to create the basic release definition. Ensure that the linked source is the build definition we created earlier.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;From within the release definition edit screen, navigate to the &lt;code&gt;Triggers&lt;/code&gt; menu.&lt;/li&gt;
&lt;li&gt;Check the &lt;code&gt;Continuous Deployment&lt;/code&gt; check box.&lt;/li&gt;
&lt;li&gt;Select the build as the source from the drop down and the branch it should monitor.&lt;/li&gt;
&lt;li&gt;Add &lt;code&gt;schedule&lt;/code&gt; as the tag filter.&lt;/li&gt;
&lt;li&gt;Click &lt;code&gt;Save&lt;/code&gt; to confirm changes.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmCICD/60_ReleaseDefinition.png" alt="Updated Release Definition" /&gt;&lt;/p&gt;

&lt;h2&gt;Verification&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Verify that the when the build is triggered via the schedule and that it has a &lt;code&gt;schedule&lt;/code&gt; tag is associated upon completion.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmCICD/70_ScheduledBuild.png" alt="Verify Build" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Verify that a release was deployed off of it.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/CrmCICD/80_TriggeredRelease.png" alt="Verify Build" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.visualstudio.com/learn/what-is-continuous-integration/"&gt;What is Continuous Integration? | DevOps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.visualstudio.com/learn/what-is-continuous-delivery/"&gt;What is Continuous Delivery? | DevOps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://puppet.com/blog/continuous-delivery-vs-continuous-deployment-what-s-diff"&gt;Continuous Delivery Vs. Continuous Deployment: What's the Diff? | Puppet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/417134/continuous-integration-vs-nightly-builds"&gt;Continuous Integration vs. Nightly Builds - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.visualstudio.com/en-us/docs/build/define/triggers"&gt;Build definition triggers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://roadtoalm.com/2017/03/30/trigger-release-pipeline-only-for-scheduled-builds/"&gt;Trigger Release Pipeline only for Scheduled builds | The Road to ALM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.visualstudio.com/en-us/docs/build/scripts/"&gt;Use a PowerShell script to customize your build process&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.visualstudio.com/en-us/docs/build/define/variables"&gt;Build variables&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>http://nullfactory.net/2017/06/enforce-coding-standards-by-integrating-stylecop-validations/</id><title type="text">Enforce Code Standards by Integrating StyleCop Validations</title><summary type="html">&lt;p&gt;StyleCop is a configurable analysis library that ensures code produced conforms to it's coding standard. While the benefits of a consistent coding standard is clear, each team has there own strong opinions how it should be enforced. &lt;/p&gt;

&lt;p&gt;In my previous projects I've used the &lt;code&gt;StyleCop.MsBuild&lt;/code&gt; package and have been eager to try out the code analyzer version of the tool. In this post, I will start off with a quick run down of my attempt at integrating it into a solution.&lt;/p&gt;

&lt;h2&gt;Prerequisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Visual Studio Professional 2015 or higher. Its not really necessary, but makes for an easier setup and nicer integration with the Roslyn base analyzer. &lt;/li&gt;
&lt;li&gt;If integrating with an SCM or Automated build -  Visual Studio Team Services (VSTS) using git. The steps are not limited to VSTS, but its just my personal preference.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Installation&lt;/h2&gt;

&lt;p&gt;Installation itself is pretty simple - just install the &lt;code&gt;StyleCop.Analyzers&lt;/code&gt; nuget package by running the following command in the package manager console witihin Visual Studio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Install-Package StyleCop.Analyzers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That's it. That all we need to do to get started.&lt;/p&gt;

&lt;h2&gt;Warning Vs. Error&lt;/h2&gt;

&lt;p&gt;By default StyleCop treats suggestions as warnings, but I prefer to go strict mode and treat all style cop validations as errors. This means that build actually fails if the code does not adhere to the style validations. My justification is that its always cheaper to fix these issues early in the development cycle as well as minimizing &lt;a href="https://blog.codinghorror.com/the-broken-window-theory/"&gt;"broken windows syndrome"&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When using the older &lt;code&gt;StyleCop.MSBuild&lt;/code&gt; package, I could just set the &lt;code&gt;StyleCopTreatErrorsAsWarnings&lt;/code&gt; environmental variable in the development machine or the team build and it will ensure that the the scope is limited to the StyleCop errors only. Unfortunately, with the Analyzers project it does not seem to be that simple. There exists an &lt;code&gt;TreatWarningsAsErrors&lt;/code&gt; environmental variable, but this is global and treats any warnings as errors - not what I want.&lt;/p&gt;

</summary><published>2017-06-10T14:00:00Z</published><updated>2017-06-10T14:00:00Z</updated><link rel="alternate" href="http://nullfactory.net/2017/06/enforce-coding-standards-by-integrating-stylecop-validations/" /><content type="html">&lt;p&gt;StyleCop is a configurable analysis library that ensures code produced conforms to it's coding standard. While the benefits of a consistent coding standard is clear, each team has there own strong opinions how it should be enforced. &lt;/p&gt;

&lt;p&gt;In my previous projects I've used the &lt;code&gt;StyleCop.MsBuild&lt;/code&gt; package and have been eager to try out the code analyzer version of the tool. In this post, I will start off with a quick run down of my attempt at integrating it into a solution.&lt;/p&gt;

&lt;h2&gt;Prerequisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Visual Studio Professional 2015 or higher. Its not really necessary, but makes for an easier setup and nicer integration with the Roslyn base analyzer. &lt;/li&gt;
&lt;li&gt;If integrating with an SCM or Automated build -  Visual Studio Team Services (VSTS) using git. The steps are not limited to VSTS, but its just my personal preference.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Installation&lt;/h2&gt;

&lt;p&gt;Installation itself is pretty simple - just install the &lt;code&gt;StyleCop.Analyzers&lt;/code&gt; nuget package by running the following command in the package manager console witihin Visual Studio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Install-Package StyleCop.Analyzers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That's it. That all we need to do to get started.&lt;/p&gt;

&lt;h2&gt;Warning Vs. Error&lt;/h2&gt;

&lt;p&gt;By default StyleCop treats suggestions as warnings, but I prefer to go strict mode and treat all style cop validations as errors. This means that build actually fails if the code does not adhere to the style validations. My justification is that its always cheaper to fix these issues early in the development cycle as well as minimizing &lt;a href="https://blog.codinghorror.com/the-broken-window-theory/"&gt;"broken windows syndrome"&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When using the older &lt;code&gt;StyleCop.MSBuild&lt;/code&gt; package, I could just set the &lt;code&gt;StyleCopTreatErrorsAsWarnings&lt;/code&gt; environmental variable in the development machine or the team build and it will ensure that the the scope is limited to the StyleCop errors only. Unfortunately, with the Analyzers project it does not seem to be that simple. There exists an &lt;code&gt;TreatWarningsAsErrors&lt;/code&gt; environmental variable, but this is global and treats any warnings as errors - not what I want.&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;So my plan is to create two rule sets and tie them down to two individual configurations. I will create one rule set used in the debug configuration and then a stricter one for the release configuration.&lt;/p&gt;

&lt;p&gt;Now let's configure the rules:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Let's create a very simple console application called &lt;code&gt;AnalyzersDemo&lt;/code&gt;and open it up in Visual Studio.&lt;/li&gt;
&lt;li&gt;Install the &lt;code&gt;StyleCop.Analyzers&lt;/code&gt; package into the project.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, navigate to the &lt;code&gt;Analyze &amp;gt; Configure Code Analysis &amp;gt; For AnalyzersDemo]&lt;/code&gt; menu option.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/StyleCopInteg/10_configureanalysis.png" alt="Code Analysis" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In the resulting dialog, accept the default values by clicking the &lt;code&gt;Open&lt;/code&gt; button. This will open a dialog that allows us to configure the behaviour of the rule sets.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/StyleCopInteg/20_opencustomize.png" alt="Code Analysis Customize" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Select all the warnings related to &lt;code&gt;StyleCop.Analyzers&lt;/code&gt; and update the Action to &lt;code&gt;Error&lt;/code&gt;. Notice that a new rule set file has been created.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/StyleCopInteg/30_customizerules.png" alt="Code Analysis Customize Rules" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Duplicate the rule set file and rename them &lt;code&gt;BaseRuleset.ruleset&lt;/code&gt; to &lt;code&gt;StrictRuleset.ruleset&lt;/code&gt;. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Move them them up as solution items. This is so that we can share the same rule sets against all the projects.&lt;/li&gt;
&lt;li&gt;Edit the files and give the name and descriptions more meaningful values.&lt;/li&gt;
&lt;li&gt;Remove all nodes except for the &lt;code&gt;&amp;lt;RuleSet&amp;gt;&lt;/code&gt; root node from the &lt;code&gt;BaseRuleset&lt;/code&gt; file so that it will revert the default action level.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, associate the two rule sets with the different configurations; the &lt;code&gt;BaseRuleset&lt;/code&gt; and &lt;code&gt;StrictRuleset&lt;/code&gt; to the &lt;code&gt;debug&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; configuration respectively.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/StyleCopInteg/40_debugrules.png" alt="Debug RuleSet" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/StyleCopInteg/50_releaserules.png" alt="Release RuleSet" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This is the final project structure:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/StyleCopInteg/60_projectstructure.png" alt="Project Structure" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now the strict validation is performed only when a &lt;code&gt;release&lt;/code&gt; build is performed.&lt;/p&gt;

&lt;h2&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;One may argue that the "draconian mode" of enforcing styles is not worth the potential disruption it causes.  So let's try to compromise - If your source control strategy uses multiple branches (which you should always do, by the way), the strict mode can be enforced as a gated check-in. This means that the rules are enforced only when a pull-request is made into the &lt;code&gt;master&lt;/code&gt; branch. Refer my &lt;a href="http://nullfactory.net/2017/05/gated-checkins-in-vsts-using-tfsvc-and-git/"&gt;previous post&lt;/a&gt; on setting up a gated branch policy.&lt;/p&gt;

&lt;p&gt;More information on customization of the StyleCop rules can be found &lt;a href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/Configuration.md"&gt;here&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;And finally, here is a build manually executed with an explicit configuration:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/StyleCopInteg/65_queuebuild.png" alt="Queue Build" /&gt;&lt;/p&gt;

&lt;p&gt;The failure in a &lt;code&gt;release&lt;/code&gt; configuration:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/StyleCopInteg/70_releasebuild.png" alt="Release Build" /&gt;&lt;/p&gt;

&lt;p&gt;And warnings in &lt;code&gt;debug&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://nullfactory.net/images/posts/StyleCopInteg/80_debugbuild.png" alt="Debug Build" /&gt;&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://stylecop.codeplex.com/wikipage?title=Setting%20Up%20StyleCop%20MSBuild%20Integration"&gt;StyleCop - Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tech.marketinvoice.com/2015/09/06/using-roslyn-analysers/"&gt;Using, configuring and distributing Roslyn analysers in teams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/StyleCop.MSBuild/"&gt;NuGet Gallery | StyleCop.MSBuild 4.7.55&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers"&gt;GitHub - DotNetAnalyzers/StyleCopAnalyzers: An implementation of StyleCop rules using the .NET Compiler Platform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.codinghorror.com/the-broken-window-theory/"&gt;The Broken Window Theory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry></feed>